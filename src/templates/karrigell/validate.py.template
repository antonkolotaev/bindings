from HTMLTags import *
from Queue import Empty
from multiprocessing import Process,Queue
from time import time
from copy import copy
from itertools import *

saved_REQUEST = copy(REQUEST)

Include('import.py')

from kspremia.result_kinds import *
from kspremia import enum
from kspremia import vector
from kspremia import vector_compact
from kspremia import scalar

def rowEx(c1, c2, c3=''):
   return [TD(c1,align='right')+TD(c2)+TD(c3)] 

def row2(c1, c2):
   return [TD(c1,align='right')+TD(c2)] 

def spannedRowsEx(c1, c2s, c3=''):
   return [TD(c1, align='right',rowspan=len(c2s)) + TD(c2s[0]) + TD(c3, rowspan=len(c2s))] + \
          [TD(c2s[i]) for i in range(1,len(c2s))]

def spannedRows2(c1, c2s):
   return [TD(c1, align='right',rowspan=len(c2s)) + TD(c2s[0])] + \
          [TD(c2s[i]) for i in range(1,len(c2s))]

def spannedColEx(c):
   return [TD(c, colspan='3')]

def addRowsToTable(table, rows, colors):
   color_idx = 0
   for r in rows:
      color_idx = color_idx + 1
      try:
         for rr in r:
            table <= TR(rr, bgcolor=clr(colors, color_idx))
      except Exception, ex:
         print "r=(",type(r), dir(r), type(r).__name__,")"

class cached_property(object):
    '''A read-only @property that is only evaluated once. The value is cached
    on the object itself rather than the function or class; this should prevent
    memory leakage.'''
    def __init__(self, fget, doc=None):
        self.fget = fget
        self.__doc__ = doc or fget.__doc__
        self.__name__ = fget.__name__
        self.__module__ = fget.__module__

    def __get__(self, obj, cls):
        if obj is None:
            return self
        obj.__dict__[self.__name__] = result = self.fget(obj)
        return result

graph_t = """
  <head>
  </head>
  <body>
    <style type="text/css">
      body {
        margin: 0px;
        padding: 0px;
      }
      #qqq {
        width : 600px;
        height: 384px;
        margin: 8px auto;
      }
    </style>
  <table>
   <tr>
      <td>
         <div id="qqq">
      </td>
   </tr>
  </table>
    <!--[if lt IE 9]>
    <script type="text/javascript" src="flashcanvas.js"></script>
    <![endif]-->
    <script type="text/javascript" src="premia/flotr2.min.js"></script>
    <script type="text/javascript">
(function basic_legend(container) {

  var
    graph;


  function labelFn (label) {
    return label;
  }

  // Draw graph
  graph = Flotr.draw(container, datas, {
    legend : {
      position : 'se',            // Position the legend 'south-east'.
      labelFormatter : labelFn,   // Format the labels.
      backgroundColor : '#D2E8FF' // A light blue background color.
    },
    HtmlText : false
  });
})(document.getElementById('qqq'));      
    </script>
  </body>
"""


# object defining per-user data   
session = Session()

# Type: corrected_output_parameter_name : string
# -> (should_it_be_in_graph_by_default : bool, its_kind_id : int)
# here we just add a 'Time' output parameter which is not show by default
result_kinds['Time'] = (False,-1)

def checkbox(vname,checked=True, disabled = False):
   """
   Returns a checkbox with given name
   checked - is the checkbox checked
   disabled - is the checkbox disabled 
   """
   return INPUT(type="checkbox", 
                name=vname, 
                value="1", 
                align="right", 
                checked=checked, 
                disabled = disabled) 
   
# This class contains arrays representing possible iteration over some entity parameter
# All the arrays have the first element corresponding to No Iteration case
# Following elemenets represent data for iterable entity parameters
# If a parameter is of PNLVECT type of size N, these array contain N its components
# If a parameter is of PNLVECTCOMPACT type of size N, 
#     these array contain N its components if it is heterogenous, or 1 component if homogenous
# If a parameter if ENUM type, its parameters, if any, appear in these arrays 
# _iterables  - printable labels for iterable parameters. Type: string list
# _iterables_corr - corrected names for variables. Type: string list
# _iterables_getter - functions returning parameter's value from the entity.
#                    Type: list<() -> (int | double)>
# _iterables_setter - functions setting parameter's value in the entity.
#                    Type: list<(int | double) -> ()>
# TODO: introduce IterableParam class
# reload : bool  - flag showing should we try to load entity params from the form sent
class Iterables:

   def __init__(self, parent):
      # 
      self._iterables = ['No iteration']
      self._iterables_corr = ['']
      self._iterables_getter = ['']
      self._iterables_setter = ['']
      self._iterables = ['No iteration']
      self.reload = True
      self.parent = parent
      
   def __len__(self): return len(self._iterables)
      
   @property
   def entity(self):
      return self.parent.entity
  
   @property
   def labels(self):
      return self._iterables
      
   def checkIdx(self, idx):
      assert 0 <= idx and idx < len(self._iterables_corr)
      
   def getCorrectedName(self, idx):
      self.checkIdx(idx)
      return self._iterables_corr[idx]
      
   def lookupByCorrectedName(self, correctedName):
      if correctedName in self._iterables_corr: 
         return self._iterables_corr.index(correctedName)
      else:
         return 0
   
      
   def getGetter(self, idx):
      self.checkIdx(idx)
      return self._iterables_getter[idx]

   def getSetter(self, idx):
      self.checkIdx(idx)
      return self._iterables_setter[idx]


class IterationState(object):

   def __init__(self, obj, iterables, idx, iterateTo, stepsNo):
      self.obj = obj
      self.idx = idx
      self.label = iterables.getCorrectedName(idx) 
      self.name = iterables.labels[idx]
      self.getter = iterables.getGetter(idx)
      self.setter = iterables.getSetter(idx)
      self.iterateTo = iterateTo
      self.stepsNo = stepsNo


class VisitorBase(object):

   def __init__(self, state = None):
      self.state = state

   def addError(self, msg): add_error(msg)

   @property
   def entity(self):
      return self.state.rawObj   
      
   @property
   def entityLabel(self):
      return self.state.entityLabel

   def comb(self, x,y): return None

class Loader(VisitorBase):

   def __init__(self, state):
      VisitorBase.__init__(self, state)
      self.REQUEST = REQUEST
      self.reload = True
      
   def enumVisitor(self): return EnumLoader   

   def get(self, key, func):
      if key in self.REQUEST:
         func(self.REQUEST[key])
         return True
      else:
         return False
      
   def process(self, field):  
      try:
         if self.reload:
            field.load(self)
      except Exception, ex:
         v.addError('Error in '+ field.propertyName +':' + str(ex))

class Renderer(VisitorBase):

   def __init__(self, table=None, colors=None, state=None):
      VisitorBase.__init__(self,state)
      self.table = table 
      self.colors = colors 
      
   def clrinc(self): clrinc()
   @property
   def currentColor(self): return clr(self.colors,clridx)
   
   def process(self, field):  
      return field.render(self)

   def comb(self, x,y): 
      return x + y

   def enumVisitor(self): return EnumRenderer

   def rowEx(self, c1, c2, c3=''):
      return [TD(c1,align='right') + TD(c2)+TD(c3)]

   def spannedRowsEx(self, c1, c2s, c3=''):
      return [TD(c1, align='right',rowspan=len(c2s)) + TD(c2s[0]) + TD(c3, rowspan=len(c2s))] + \
             [TD(c2s[i]) for i in range(1,len(c2s))]

class RendererH(Renderer):

   def __init__(self, state):
      Renderer.__init__(self, state=state)

   def process(self, field):
      return field.renderHistoryEx(self)

   def enumVisitor(self):
      return EnumRendererH

   @property
   def entity(self):
      return self.state.obj   

class IterablesExtractor(VisitorBase):

   def __init__(self, state):
      VisitorBase.__init__(self, state)
      self.ctx = Iterables(self)
      
   def addError(self, msg): add_error(msg)
      
   def process(self, field):  field.getIterables(self)

   def enumVisitor(self): return EnumIterablesExtractor   

class EnumVisitorBase(object):

   def __init__(self, source, member, enum):
      self.member = member
      self.enum = enum
      self.source = source

   def processX(self):
      return reduce(self.source.comb, 
                    map(lambda f: f.process(self),
                        self.enum.getFields(self.value)), 
                    self.header)

   @cached_property      
   def value(self):   
      return self.enum.labels.index(self.member._labels[self.member._value.key()])

   @cached_property
   def header(self):
      return None
   
   @property
   def entity(self):
      return self.member._value
         
class EnumLoader(EnumVisitorBase, Loader):

   def __init__(self, source, member, enum):
      EnumVisitorBase.__init__(self, source, member, enum)
      Loader.__init__(self, source.state)

      e = int(self.REQUEST[self.enum.fullName] if self.enum.fullName in self.REQUEST else '0')
      self.enum.initEnum(self.member, e)


class EnumRenderer(EnumVisitorBase, Renderer):

   def __init__(self, source, member, enum):
      EnumVisitorBase.__init__(self, source, member, enum)
      Renderer.__init__(self, state = source.state)

   @cached_property
   def header(self):
      if self.enum.should_be_reloaded:
         L = SELECT(name = self.enum.fullName, onchange='submit();').from_list(self.enum.labels)
      else:
         L = SELECT(name = self.enum.fullName).from_list(self.enum.labels)
         
      L.select(value=self.value)
      
      return [self.rowEx(self.enum.friendlyName, L)]

class EnumRendererH(EnumVisitorBase, RendererH):

   def __init__(self, source, member, enum):
      EnumVisitorBase.__init__(self, source, member, enum)
      RendererH.__init__(self, state = source.state)

   @cached_property
   def header(self):
      return [self.rowEx(self.enum.friendlyName, self.enum.labels[self.value])]

class EnumIterablesExtractor(EnumVisitorBase, IterablesExtractor):

   def __init__(self, source, member, enum):
      EnumVisitorBase.__init__(self, source, member, enum)
      IterablesExtractor.__init__(self, source.state)
      self.ctx = source.ctx

def extlist(lst,size):
    if len(lst) < size:
        lst.extend((size - len(lst)) * [lst[len(lst) - 1]])

def enum(n,e):
    L = SELECT(name = n, onchange="submit();").from_list(e._labels.values())
    L.select(value=e._labels.keys().index(e._value.key()))
    return L
    
def setEnumValueByIdx(e,idx):
    e._value = e._labels.keys()[int(idx)]

def enum_submit_mod(n,names,v):
    L = SELECT(name = n, onchange="submit();").from_list(names)
    L.select(value=names.index(v))
    return L

def enum_submit(n,classes,v):
    names = [x.__name__ for x in classes]
    L = SELECT(name = n, onchange="submit();").from_list(names)
    L.select(value=names.index(v))
    return L

def pricing_options(model_name, family_name):
    return eval('pricings.' + model_name + '.' + model_name + '_' + family_name + '.methods_for_options()').keys()

mod_colors = ['lightgreen','white']
opt_colors = ['#FFFFC0', 'white']
met_colors = ['lightblue','white']
res_colors = ['lightgray', 'white']

def clr(color_table,idx): return color_table[idx%%len(color_table)]

g_err_table = TABLE(Class="content")
g_errors = []

def add_error(s): 
    g_err_table <= TR(TD(s), bgcolor='#C00000')
    g_errors.append(s)

def myImport(m):
   exec 'import ' + m
   return eval(m)

def getMethodModule(m,f,meth): 
   return myImport('kspremia.mod.'+m+'.'+m+'_'+f+'.'+meth)

def uriPart(key,value):
   return '&' + key + '=' + value

class StateCommonBase(object):
   
   @cached_property
   def name(self):
      return self.ksModule.name()

   @cached_property
   def visitFields(self):
      def inner(v):
         return reduce(v.comb, map(lambda x: x.process(v), self.ksModule.fields()), [])         
      return inner

   @cached_property
   def rows(self):
      return self.header + self.visitFields(self.createRenderer())  

   @cached_property
   def myHeaderImpl(self):
      return [rowEx(B(self.printLabel), self.headerContent)]      

   @cached_property
   def header(self):
      return self.myHeaderImpl

   @cached_property
   def table(self):
      table = TABLE(Class="content")
      addRowsToTable(table, self.rows, self.colors)
      return table


class StateBase(StateCommonBase):

   def __init__(self, parent):
      self.parent = parent

   @cached_property
   def request(self):
      return saved_REQUEST

   def tryGet(self, key, defaultValue):
      return self.request[key] if key in self.request else defaultValue

   def tryGet3(self, key, postfunc, defaultValue):
      return postfunc(self.request[key]) if key in self.request else defaultValue

   @cached_property
   def pyType(self):
      return self.ksModule.underlyingType()

   @cached_property
   def rawObj(self):
      return self.pyType()

   @cached_property
   def obj(self):
      loader = Loader(self)
      self.visitFields(loader)
      return loader.entity

   @cached_property
   def id(self):
      if self.predsChanged:
         return self.idChoices[0]
      else:
         return self.tryGet3(self.reqLabel, lambda x: self.idChoices[int(x)], self.old_id)

   @cached_property
   def uri(self):
      return uriPart(self.uriToken, self.id) + self.itUri

   @cached_property
   def itUri(self):
      return uriPart(self.uriOldItIdx, str(self.iterationIdx)) \
                  if 'uriOldItIdx' in dir(self) else ''

   @cached_property
   def idChanged(self):
      return self.old_id <> self.id

   @cached_property
   def old_id(self):
      return self.tryGet(self.uriToken, self.defaultValue)

   @cached_property
   def idChoices(self):
      return self.nameChoices

   @cached_property
   def nameChoices(self):
      return map(lambda x: x.__name__, self.choices) 

   def clrinc(self): clrinc()
   @property
   def currentColor(self): return clr(self.colors,clridx)

   @cached_property
   def oldIterationIdx(self):
      return int(self.request[self.uriOldItIdx] if self.uriOldItIdx in self.request else '0')

   @cached_property
   def srcIterationIdx(self):
      return int(self.request[self.reqItIdx] if self.reqItIdx in self.request else '0') 

   @cached_property
   def iterables(self):
      extractor = IterablesExtractor(self)
      self.visitFields(extractor)
      return extractor.ctx

   @cached_property
   def iterationLabel(self):
      return self.tryGet('il', None)
      
   @cached_property
   def fixedIterationIdx(state):
      if state.oldIterationIdx == state.iterationIdx and state.iterationLabel <> None and state.iterationIdx <> 0:
         if state.iterationIdx >= len(state.iterables) or state.iterationLabel <> state.iterables.getCorrectedName(state.iterationIdx):
            return state.iterables.lookupByCorrectedName(state.iterationLabel)
      return state.iterationIdx

   @cached_property
   def iterateVlabel(self):
      return 'iterate_' + self.entityLabel

   @cached_property
   def iterateValueVlabel(self):
      return self.iterateVlabel + '_' + self.iterables.getCorrectedName(self.fixedIterationIdx)

   @cached_property
   def oldIterationValue(self):
      if self.iterateValueVlabel in self.request:
         return float(self.request[self.iterateValueVlabel])
      else:
         return self.iterables.getGetter(self.fixedIterationIdx)()

   @cached_property
   def iterationStepNumber(self):
      return int(self.tryGet('iteration_steps', '10'))
      
   @cached_property
   def iteration(self):
      if self.fixedIterationIdx == 0:
         return None
      else:
         return IterationState(self.obj, self.iterables, self.fixedIterationIdx, self.oldIterationValue, self.iterationStepNumber)

   @cached_property
   def iterationIdx(self):
      if self.idChanged or self.otherItIdxChanged:
         return 0
      else:
         return self.srcIterationIdx  

   @cached_property
   def iterationIdxChanged(self):
      return self.oldIterationIdx <> self.srcIterationIdx

   def createRenderer(self):
      return Renderer(state = self)

   @cached_property
   def rows(self):
      return super(StateBase,self).rows + self.iterationRows 

   @cached_property
   def headerContent(self):
      return enum_submit_mod(self.reqLabel, self.nameChoices, self.name)

   @cached_property
   def iterationRows(state):

      mc = enum_submit_mod(state.iterateVlabel, state.iterables.labels, state.iterables.labels[state.fixedIterationIdx])

      table = [rowEx('Iterate', mc, '')]
         
      if state.fixedIterationIdx <> 0:

         return table + [
            rowEx('Iterate To', INPUT(name=state.iterateValueVlabel,value=state.oldIterationValue),''), 
            rowEx('#Iterations', INPUT(name='iteration_steps',value=state.iterationStepNumber),'')
            ]

      return table

class AssetStateBase(object):

   printLabel = 'Asset Type:'

   @cached_property
   def name(self):
      return self.id


class AssetState(AssetStateBase, StateBase):

   @cached_property
   def choices(self):
      return assets.all()

   reqLabel = 'asset_type'
   uriToken = 'a'
   defaultValue = 'equity_Black_Scholes_type'

   @cached_property 
   def predsChanged(self):
      return False 

class ModelStateBase(object):

   colors = mod_colors
   printLabel = 'Model:'

   @cached_property
   def ksModule(self): 
      return myImport('kspremia.mod.' + self.id + '.model')

   @cached_property
   def header(self):
      return self.parent.asset.header + self.myHeaderImpl


class ModelState(ModelStateBase, StateBase):

   @cached_property
   def choices(self):
      return eval('assets.' + self.parent.asset.id + '.models()')

   @cached_property
   def idChoices(self):
      return map(lambda x: x.ID(), self.choices)

   entityLabel = 'model'
   reqLabel = 'model'
   uriToken = 'm'
   defaultValue = 'BS1D'
   uriOldItIdx = 'im'
   reqItIdx = 'iterate_model'

   @cached_property 
   def predsChanged(self):
      return self.parent.asset.idChanged 

   @cached_property
   def otherItIdxChanged(self):
      return \
         self.parent.option.iterationIdxChanged or \
         self.parent.method.iterationIdxChanged

class FamilyStateBase(object):

   printLabel = 'Family:'

   @cached_property
   def name(self):
      return self.id

class FamilyState(FamilyStateBase, StateBase):

   @cached_property
   def choices(self):
      return self.parent.model.obj.families()

   @cached_property
   def nameChoices(self):
      return self.choices

   reqLabel = 'family'
   uriToken = 'f'
   defaultValue = 'STD'

   @cached_property 
   def predsChanged(self):
      return self.parent.model.idChanged

class OptionStateBase(object):

   @cached_property
   def ksModule(self):
      return myImport('kspremia.opt.'+self.parent.family.id+'.'+self.id)    

   colors = opt_colors
   printLabel = 'Option:'

   @cached_property
   def header(self):
      return self.parent.family.header + self.myHeaderImpl


class OptionState(OptionStateBase, StateBase):

   @cached_property
   def choices(self):
      return pricing_options(self.parent.model.id,self.parent.family.id)

   entityLabel = 'option'
   reqLabel = 'option'
   uriToken = 'o'
   defaultValue = 'CallEuro'
   uriOldItIdx = 'io'
   reqItIdx = 'iterate_option'

   @cached_property 
   def predsChanged(self):
      return self.parent.family.idChanged or self.parent.model.idChanged

   @cached_property
   def otherItIdxChanged(self):
      return \
         self.parent.model.iterationIdxChanged or \
         self.parent.method.iterationIdxChanged

class ResultMemberCommonBase(object):

   def __init__(self, correctedName, friendlyName, enabled=True):
      self.friendlyName = friendlyName
      self.correctedName = correctedName
      self.enabled = enabled

   @cached_property
   def request(self):
      return REQUEST

   def tryGet(self, key, defaultValue):
      return self.request[key] if key in self.request else defaultValue

   @cached_property
   def oldLabel(self):
      return self.tryGet('showGraphLabel_'+self.correctedName, self.friendlyName)

   @cached_property
   def rows(self): 
      return rowEx('', 
                   INPUT(name='showGraphLabel_'+self.correctedName, value=self.friendlyName, disabled = not self.enabled), 
                   checkbox('showGraph_'+self.correctedName, checked = self.oldChecked, disabled = not self.enabled))


class ResultMember(ResultMemberCommonBase):

   @cached_property
   def oldChecked(self):
      return result_kinds[self.correctedName][0]

class MethodStateBase(object):

   colors = met_colors
   printLabel = 'Pricing method:'

   @cached_property
   def ksModule(self):
      return getMethodModule(self.parent.model.id, self.parent.family.id, self.id)

   @cached_property
   def rows(self):
      return self.superRows + self.resultTable

   @cached_property
   def resultTable(self):
      return \
         [spannedColEx('Show results in a graph')] + \
         map(lambda t: t.rows, self.resultMembers)  \
         if self.showResultMembers else []


class MethodState(MethodStateBase, StateBase):

   @cached_property
   def choices(self):
      m = self.parent.model.id
      f = self.parent.family.id
      opt = self.parent.option.obj
      return [x for x in eval('pricings.' + m + '.' + m + '_' + f + '.all()') if type(opt) in x.options()]

   entityLabel = 'method'
   reqLabel = 'pricing_method'
   uriToken = 'meth'
   defaultValue = 'CF_Call'
   uriOldItIdx = 'ip'
   reqItIdx = 'iterate_method'

   @cached_property
   def superRows(self):
      return StateBase.rows.__get__(self, None)

   @property 
   def showResultMembers(self):
      return self.parent.iteration

   @cached_property 
   def predsChanged(self):
      return self.parent.option.idChanged or self.parent.model.idChanged

   @cached_property
   def resultMembers(self):
      return map(lambda t: ResultMember(t[0],t[1]), 
                 self.ksModule.resultFields() + [('Time', 'Computation Time')]) 

   @cached_property
   def otherItIdxChanged(self):
      return \
         self.parent.option.iterationIdxChanged or \
         self.parent.model.iterationIdxChanged

class ScalarResultBase(object):

   @staticmethod
   def renderScalarResultElement((k,v)):
      return [spannedRows2(k, v)] if type(v) == list else [row2(k, v)]

   @cached_property
   def rows(self):
      return reduce(lambda x,y: x+y, map(self.renderScalarResultElement, self.result),[row2('Result','')])

   @cached_property
   def table(self):
      if self.result <> None:
         addRowsToTable(self.parent.method.table, self.rows, res_colors)
      return self.parent.method.table


class ScalarResult(ScalarResultBase):

   def __init__(self, parent):
      self.parent = parent
      self.computation_timeout = parent.computation_timeout

   @cached_property
   def result(self):
      res = []
      def F(opt, mod, q):
         begin = time()
         res = self.parent.method.obj(opt, mod)
         end = time()
         res.append(("Time", end - begin))
         q.put(res)
      try:
         queue = Queue()
         process = Process(target = F, args = (self.parent.option.obj,self.parent.model.obj, queue))
         process.start()
         try:
            res = queue.get(timeout=self.computation_timeout)
         except Empty, exc:
            process.terminate()
            raise Exception("Method has worked more than " + str(self.computation_timeout) + "s. Please try another parameter combination")
         process.join(timeout=self.computation_timeout)
      except Exception, exc:
         add_error(exc)
      return res 

def rowKV(k,v):
   return [TD(k,align='right') + Sum([TD(L) for L in v])]

def spannedRowsKV(k,v):
   dim = len(v[0])
   return [TD(k, align='right',rowspan=dim) + Sum([TD(L[0]) for L in v])] + \
                                map(lambda i: Sum([TD(L[i]) for L in v]), range(1, dim))

def script(s):
   """
    print "<script type=\"text/javascript\">"
    print s
    print "</script>"
   """
   return SCRIPT(s, type=r"text/javascript")

def todata(header, v):
   s = "["
   for i in range(len(v)):
      s += "[" + str(header[i]) + "," + str(v[i]) + "],"
   s += "]"
   return s

def groupByFirst(xs):
   res = {}
   for k,v in xs:
      if k not in res:
         res[k] = []
      res[k].append(v)
   return res

def quote(s):
   return "\'"+s+"\'"

class Serie(object):

   def __init__(self, label, data):
      self.label = label
      self.data = data

   def __repr__(self):
      return "(" + self.label + ":" + self.data + ")"

class ResultElementBase(object):

   def __init__(self, parent):
      self.parent = parent
      self.domain = parent.domain

   @cached_property 
   def showGraphLabel(self):
      return REQUEST['showGraphLabel_' + self.vlabel]

   @cached_property
   def showOnGraph(self):
      return 'showGraph_'+self.vlabel in REQUEST

   @cached_property
   def labels(self):
      return [(self.showGraphLabel, self.showOnGraph)]

   @cached_property
   def series(self):
      kind = result_kinds[self.label][1]
      return [] if not self.showOnGraph else \
             [(kind, Serie(self.showGraphLabel, todata(self.parent.domain, self.data)))]

   @cached_property
   def rows(self):
      return rowKV(self.label, self.data)

   @cached_property
   def resHH(self):
      return [(self.vlabel,self.showGraphLabel, self.data)] if self.showOnGraph else []



class ResultElementVBase(object):

   def __init__(self, parent, (k,v)):
      self.parent = parent
      self.domain = parent.domain
      self.label = k
      self.data = v

   @cached_property
   def elements(self):
      return map(lambda i: self.vectorResultElement(self, (self.label,self.data), i), 
                 range(len(self.data[0])))            

   @cached_property
   def series(self):
      return chain(*map(lambda e: e.series, self.elements))

   @cached_property
   def rows(self):
      return spannedRowsKV(self.label, self.data)

   @cached_property
   def labels(self):
      return chain(*map(lambda e: e.labels, self.elements))

   @cached_property
   def resHH(self):
      return chain(*map(lambda e: e.resHH, self.elements))



class CurrentResultElement(ResultElementBase):

   def __init__(self, parent, (k,v)):
      self.parent = parent
      self.label = k
      self.data = v
      self.vlabel = k

class CurrentVectorResultElement(ResultElementBase):

   def __init__(self, parent, (k,v), i):
      self.parent = parent
      self.label = k
      self.data = v
      self.vlabel = k
      self.i = i
      self.domain = parent.domain
      self.data = map(lambda L: L[i], v)

   @cached_property 
   def showGraphLabel(self):
      return REQUEST['showGraphLabel_' + self.vlabel]+'['+str(self.i)+']'

class CurrentResultElementV(ResultElementVBase):

   def __init__(self, parent, (k,v)):
      ResultElementVBase.__init__(self, parent, (k,v))
      self.vectorResultElement = CurrentVectorResultElement

class HistoryResultElement(ResultElementBase):

   def __init__(self, parent, (k,v)):
      ResultElementBase.__init__(self, parent)
      self.label = k
      self.data = v
      self.idx = self.parent.idx
      self.vlabel = str(self.idx) + "_" + self.label

class HistoryVectorResultElement(ResultElementBase):

   def __init__(self, parent, (k,v), i):
      ResultElementBase.__init__(self, parent)
      self.label = k
      self.data = map(lambda L: L[i], v)
      self.vlabel = str(self.parent.idx) + "_" + self.label + str(i)

class HistoryResultElementV(ResultElementVBase):

   def __init__(self, parent, (k,v)):
      ResultElementVBase.__init__(self, parent, (k,v))
      self.vectorResultElement = HistoryVectorResultElement
      self.idx = parent.idx

class HistoryBase(object):

   @cached_property
   def series(self):
      return chain(*map(lambda e: e.series, self.elements)) 

class HStateBase(StateCommonBase):
   
   def createRenderer(self):
      return RendererH(self)

   @cached_property
   def headerContent(self):
      return B(self.name)

class AssetHState(AssetStateBase, HStateBase):

   def __init__(self, parent):
      self.id = parent.source[0]
      self.parent = parent

class ModelHState(ModelStateBase, HStateBase):

   def __init__(self, parent):
      self.obj = parent.source[1]
      self.parent = parent

   @property
   def id(self):
      return self.obj.ID()

class FamilyHState(FamilyStateBase, HStateBase):

   def __init__(self, parent):
      self.id = parent.option.obj.familyName()
      self.parent = parent

class OptionHState(OptionStateBase, HStateBase):

   def __init__(self, parent):
      self.obj = parent.source[2]
      self.parent = parent

   @cached_property
   def id(self):
      return type(self.obj).__name__

class HResultMember(ResultMemberCommonBase):

   @cached_property
   def oldChecked(self):
      return 'showGraph_'+self.correctedName in REQUEST and 'showGraphLabel_'+self.correctedName in REQUEST


class MethodHState(MethodStateBase, HStateBase):

   def __init__(self, parent):
      self.parent = parent
      self.obj = parent.source[3]
      self.res_labels = parent.source[4]
      self.res_t = parent.source[6]
      self.res_h = parent.source[8]
      self.h_idx = parent.h_idx
      self.h_iterate_label = parent.source[7]

   @cached_property
   def id(self):
      return type(self.obj).__name__

   @cached_property
   def superRows(self):
      return HStateBase.rows.__get__(self, None)

   @property
   def showResultMembers(self):
      return self.res_t

   @cached_property 
   def enabled(self):
      return self.h_iterate_label == state.iterationLabel

   @cached_property
   def ownResultMembers(self):
      members = []
      idx = 0  # flattened index of the output parameter being processed
      for i in range(1, len(self.res_t)): # iterating current table results
         vlabel = str(self.h_idx) + "_" + self.res_t[i][0]   # base for variable name
         if type(self.res_t[i][1][0]) == list:          # if output param is list
            for j in range(len(self.res_t[i][1][0])):   # for every component of ????
               friendly = self.res_labels[idx][0]
               idx = idx + 1   
               members.append(HResultMember(vlabel+str(j), friendly, self.enabled))
         else:
            friendly = self.res_labels[idx][0]
            idx = idx + 1   
            members.append(HResultMember(vlabel, friendly, self.enabled))
      return members

   @cached_property
   def inheritedResultMembers(self):
      members = []
      for (header, rows) in self.res_h:   # res_h is graph series for some elder run
         for (corrected, friendly, data) in rows:
            vlabel = str(self.h_idx) + "_" + corrected
            members.append(HResultMember(vlabel, friendly, self.enabled))
      return members

   @cached_property  # to be refactored
   def resultMembers(self):
      return self.ownResultMembers + self.inheritedResultMembers

class HScalarResult(ScalarResultBase):

   def __init__(self, parent):
      self.parent = parent
      self.result = parent.source[5]

class IterationResultBase(object):

   @cached_property
   def headerRow(self):
      return rowKV(self.result[0][0], self.result[0][1])

   @cached_property
   def rows(self):
      return [self.headerRow] + map(lambda r: r.rows, self.results)
   
   @cached_property
   def table(self):
      table_result_i = TABLE(Class="content")
      addRowsToTable(table_result_i, self.rows, res_colors)
      return table_result_i

   @cached_property
   def domain(self):
      return self.result[0][1]

   @cached_property
   def results(self):
      def construct((k,v)):
         return CurrentResultElementV(self, (k,v)) \
                  if type(v[0]) == list \
                  else CurrentResultElement(self, (k,v))

      return map(construct, self.result[1:])

   @cached_property
   def series(self):
      return chain(*map(lambda e: e.series, self.results)) 

   @cached_property
   def dataSeries(self):
      series = list(chain(self.historySeries, self.series))
      return groupByFirst(series)

   @cached_property
   def graphs(self):
      values = self.dataSeries.values()
      def construct(i):
         return Graph(self.graphIdx(i), values[i])
      return map(construct, range(len(values)))

   @property  
   def empty(self):
      return self.result == None

   @cached_property
   def graphCode(self):
      return chain(*map(lambda e: e.code, self.graphs))

   @cached_property
   def resultLabels(self):
      return list(chain(*map(lambda e: e.labels, self.results)))

   @cached_property
   def resH(self):
      return list(self.parent.history.resH)

class HIterationResult(IterationResultBase):

   def __init__(self, parent):
      self.parent = parent
      self.result =  parent.source[6]

   @property
   def historySeries(self):
      return []
      
   def graphIdx(self, i):
      return 100+self.parent.h_idx*100 + i

class HistoryElementBase(object):

   @cached_property
   def domain(self):
      return self.rawResults[0][1]

   @cached_property
   def results(self):
      return map(self.constructResultElement, self.rawResults[1:])

   @cached_property
   def series(self):
      return chain(*map(lambda e: e.series, self.results)) 

class HistoryElement(HistoryElementBase):

   def __init__(self, parent, idx):
      self.parent = parent
      self.idx = idx
      self.source = session.history[idx]
      self.rawResults = self.source[6]
      self.iterate_label = self.source[7]
      self.h_idx = idx
      self.asset = AssetHState(self)
      self.model = ModelHState(self)
      self.option = OptionHState(self)
      self.family = FamilyHState(self)
      self.method = MethodHState(self)
      self.scalarResult = HScalarResult(self)
      self.iterationResult = HIterationResult(self)

   @cached_property
   def toRender(self):

      table = TABLE(Class="content")

      table <= TR(TD(self.model.table,valign='top')\
                 +TD(self.option.table,valign='top')\
                 +TD(self.scalarResult.table,valign='top'))

      return table + self.iterationResult.table + Sum(self.iterationResult.graphCode) \
               if not self.iterationResult.empty else table

   def constructResultElement(self, (k,v)):
      return HistoryResultElementV(self, (k,v)) \
               if type(v[0]) == list else \
             HistoryResultElement(self, (k,v))

   @cached_property
   def compatible(self):
      return self.rawResults <> None and self.iterate_label == self.parent.iteration.label

   @cached_property
   def resHH(self):
      return list(chain(*map(lambda e: e.resHH, self.results)))

   @cached_property
   def headerToSave(self):
      return (self.iterate_label, self.domain)

   @cached_property
   def resH(self):
      return [(self.headerToSave, self.resHH)] if self.compatible and len(self.resHH)>0 else []

   @cached_property
   def series(self):
      return super(HistoryElement,self).series if self.compatible else []



class History(HistoryBase):

   def __init__(self, parent):
      self.parent = parent
      N = len(session.history) if 'history' in dir(session) else 0
      self.elements = map(lambda i: HistoryElement(parent, N-i-1), range(N))

   @cached_property
   def toRender(self):
      return Sum([e.toRender for e in self.elements])

   @cached_property
   def resH(self):
      return chain(*map(lambda h: h.resH, self.elements))

class Graph(object):

   def __init__(self, id, series):
      self.id = str(id)
      self.series = series

   @cached_property
   def code(self):
         res = [script("data"+self.id+" = [];")]

         if self.series <> []:
            return res + \
               [script("data"+self.id+".push({ data : "+e.data+", label : "+quote(e.label)+" });") for e in self.series] +\
               [TEXT(graph_t.replace('qqq','containers' + self.id).replace("datas", "data"+self.id))]

         return res



class IterationResult(IterationResultBase):

   def __init__(self, parent):
      self.parent = parent
      self.computation_timeout = parent.computation_timeout

   @cached_property
   def result(self):

      iteration = self.parent.iteration

      def G(opt, mod, q):
         initial = iteration.getter()            
         for i in range(iteration.stepsNo):
             begin = time()
             if iteration.stepsNo > 1:
                 x = initial + 1. * i / (iteration.stepsNo - 1) * (iteration.iterateTo - initial)
             else:
                 x = initial
                 
             if type(initial) == type(1):
                 x = int(round(x))
             if type(initial) == type(1L):
                 x = long(round(x))
             
             iteration.setter(x)
                  
             res = (self.parent.method.obj(opt, mod))
             end = time()
             res.insert(0, (iteration.name, x))
             res.append(("Time", end - begin))
             q.put(res)
      
      res_t = []
      try: 
         queue = Queue()
         process = Process(target = G, args = (self.parent.option.obj,self.parent.model.obj, queue))
         try:            
            process.start()

            begin = time()
            iterations = iteration.stepsNo
            for i in range(iterations):
              q = queue.get(timeout=begin + self.computation_timeout - time())
              if res_t == []:
                  for k,v in q:
                      res_t.append((k,[v]))
              else:
                  idx = 0
                  for k,v in q:
                      assert res_t[idx][0] == k
                      res_t[idx][1].append(v)
                      idx = idx + 1
                             
         except Empty, exc:
            process.terminate()
            raise Exception("Method has worked more than " + str(self.computation_timeout) + "s. Please try another parameter combination")
                     
         process.join(timeout=self.computation_timeout)

      except Exception, exc:
         add_error(exc)
      return res_t

   @cached_property
   def historySeries(self):
      return self.parent.history.series

   def graphIdx(self, i): return i

"""
Class representing a single run.
"""
class State(object):

   def __init__(self):
      self.history = History(self)
      self.asset = AssetState(self)
      self.model = ModelState(self)
      self.family = FamilyState(self)
      self.option = OptionState(self)
      self.method = MethodState(self)
      self.scalarResult = ScalarResult(self)
      self.iterationResult = IterationResult(self)

   @cached_property
   def iteration(self):
      return self.model.iteration or self.option.iteration or self.method.iteration

   @cached_property
   def iterationLabel(self):
      return self.iteration.label if self.iteration <> None else '_'

   @cached_property
   def uri(self):
      return   self.asset.uri + \
               self.model.uri + \
               self.family.uri + \
               self.option.uri + \
               self.method.uri + \
               uriPart('il',self.iterationLabel)

   @cached_property
   def serialized(self):
      if self.iteration:
         print "resH = ", self.iterationResult.resH

      return (self.asset.id, 
              self.model.obj, 
              self.option.obj,
              self.method.obj, 
              self.iterationResult.resultLabels if self.iteration else None, 
              self.result, 
              self.tableResult, 
              self.iterationLabel, 
              self.iterationResult.resH if self.iteration else None) \
            if self.hasResult else None  

   @cached_property
   def hasResult(self):
      return self.result or self.tableResult

   @cached_property
   def request(self):
      return saved_REQUEST

   computation_timeout = 30

   @cached_property
   def runComputation(self):
      return g_errors == [] and 'Compute' in self.request

   @cached_property
   def result(self):
      if not self.runComputation or self.iteration <> None:
         return None
      return self.scalarResult.result

   @cached_property
   def tableResult(self):

      if not self.runComputation or self.iteration == None:
         return None

      return self.iterationResult.result


   @cached_property
   def scalarResultTable(self):
      if self.runComputation and self.iteration == None:
         return self.scalarResult.table

      return self.method.table

   @cached_property
   def toRender(self):
      # very bad. to be fixed
      self.scalarResultTable <= TR(TD() + TD(INPUT(Type="submit",name="Compute",value="Compute")))

      table = TABLE(Class="content")
      table <= TR(TD(self.model.table,valign='top') + \
                  TD(self.option.table,valign='top') + \
                  TD(self.scalarResultTable,valign='top'))

      return (table + self.iterationResult.table +Sum(self.iterationResult.graphCode)\
                if self.iteration and self.runComputation else  table) 


   
if 'history' not in dir(session):
   session.history = []

if 'ClearHistory' in REQUEST:
   session.history = []
   


state = State()

form = FORM(action='/index?'+ state.uri[1:],method="post")

if len(g_errors) > 0:
    form <= TR(TD(g_err_table))

g_table = state.toRender

form <= g_table

if state.serialized <> None:
   session.history.append(state.serialized)

if session.history <> []:
   form <= INPUT(Type="submit",name="ClearHistory",value="Clear history")

form <= state.history.toRender

print form



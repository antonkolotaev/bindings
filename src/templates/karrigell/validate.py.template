from HTMLTags import *
from Queue import Empty
from multiprocessing import Process,Queue
from time import time

Include('import.py')

class Ctx:
   def __init__(self):
      self.iterables = ['No iteration']
      self.iterables_corr = ['']
      self.iterables_getter = ['']
      self.iterables_setter = ['']

def loadScalar(property_name, vlabel, obj, conv):
    try:
       if vlabel in REQUEST:
          setattr(obj, property_name, conv(REQUEST[vlabel]))
    except Exception, ex:
       add_error('Error in '+ property_name +':' + str(ex))

def processScalar(ctx, table, colors, obj, propname, label, vlabel, constr, onChange, iterable, conv):
   loadScalar(propname, vlabel, obj, conv)
   table <= rowinc(colors, label, INPUT(name=vlabel,onchange=onChange,value=getattr(obj, propname)), constr)
   if iterable:
      ctx.iterables.append(label)
      ctx.iterables_corr.append(vlabel)
      ctx.iterables_getter.append(lambda: getattr(obj, propname))
      ctx.iterables_setter.append(lambda x: setattr(obj, propname, x)) 
   
def printVector(table, colors, label, vlabel, pmem):
   clrinc()
   table <= TR(TD(label, align='right',rowspan=len(pmem)) + TD(INPUT(name=vlabel + '[0]',value=pmem[0])) + TD('R',rowspan=len(pmem)),bgcolor=clr(colors,clridx))
   table <= Sum([TR(TD(INPUT(name=vlabel + '[' + str(i) + ']',value=pmem[i])),bgcolor=clr(colors,clridx)) for i in range(1,len(pmem))])

def iterVector(ctx, pmem, label, vlabel):
   
   for i in range(len(pmem)): 
      ctx.iterables.append(label + '[' + str(i) + ']')
      ctx.iterables_corr.append(vlabel + str(i))

   ctx.iterables_getter.extend(map(lambda x: (lambda: x), pmem))
   ctx.iterables_setter.extend(map(lambda i: (lambda z: pmem.__setitem__(i, z)), range(len(pmem))))

def loadVector(property_name, vlabel, pmem):
    try:
       for i in range(len(pmem)):
          src = vlabel + "[" + str(i) + "]"
          if src in REQUEST: 
             pmem[i] = float(REQUEST[src])
    except Exception, ex:
       add_error('Error in' + property_name + ':' + str(ex))

def processVector(ctx, table, colors, obj, propname, label, vlabel):
   pmem = getattr(obj, propname)
   loadVector(propname, vlabel, pmem)
   printVector(table, colors, label, vlabel, pmem)
   iterVector(ctx, pmem, label, vlabel)

def loadVectorCompact(property_name, vlabel, pmem):
    try:
       if vlabel + '__c' in REQUEST:
         val = float(REQUEST[vlabel + '__c'])
         for i in range(len(pmem)):                 
            pmem[i] = val
       else:
          for i in range(len(pmem)):
             src = vlabel + "[" + str(i) + "]"
             if src in REQUEST: 
                pmem[i] = float(REQUEST[src])
    except Exception, ex:
       add_error('Error in' + property_name + ':' + str(ex))

def processVectorCompact(ctx, table, colors, obj, propname, label, vlabel):
   pmem = getattr(obj, propname)
   clrinc()
   mode = None
   
   loadVectorCompact(propname, vlabel, pmem)

   if vlabel + '__t' in REQUEST:
      if REQUEST[vlabel + '__t'] == '0':
         mode = 0
      else:
         mode = 1
   else:
      if all(map(lambda x: x == pmem[0], pmem)):
         mode = 0
      else:
         mode = 1

   L = SELECT(name = vlabel+ '__t', onchange='submit();').from_list(['Constant','Array'])
   if mode == 0:
      ctx.iterables.append(label)
      ctx.iterables_corr.append(vlabel + '__c')
      ctx.iterables_getter.append(lambda: pmem[0])
      def F(x):
         for i in range(len(pmem)): pmem[i] = x          
      ctx.iterables_setter.append(F)

      L.select(value=0)
      table <= TR(TD(label, align='right',rowspan=2) + TD(L) + TD('',rowspan=2),bgcolor=clr(colors,clridx))
      table <= TR(TD(INPUT(name=vlabel + '__c',value=pmem[0])),bgcolor=clr(colors,clridx))

   if mode == 1:
      for i in range(len(pmem)): 
         ctx.iterables.append(label + '[' + str(i) + ']')
         ctx.iterables_corr.append(vlabel + str(i))
      ctx.iterables_getter.extend(map(lambda x: (lambda: x), pmem))
      ctx.iterables_setter.extend(map(lambda i: (lambda z: pmem.__setitem__(i, z)), range(len(pmem))))
      
      L.select(value=1)
      table <= TR(TD(label, align='right',rowspan=len(pmem)+1) + TD(L) + TD('R',rowspan=len(pmem)+1),bgcolor=clr(colors,clridx))
      table <= Sum([TR(TD(INPUT(name=vlabel + '[' + str(i) + ']',value=pmem[i])),bgcolor=clr(colors,clridx)) for i in range(0,len(pmem))])

def processIteration(ctx, obj, entity, colors):

   G = globals()
   
   clrinc()
   iterate_vlabel = 'iterate_'+entity
   _iterate_vlabel = '_iterate_'+entity
   
   if _iterate_vlabel in G:
      iterate_idx = int(G[_iterate_vlabel])
   else:
      iterate_idx = 0

   old_idx = G['oldit'][entity]
   print "old_idx=",old_idx, "iterate_idx=", iterate_idx
   if old_idx == iterate_idx and 'il' in REQUEST and iterate_idx <> 0:
      print iterate_idx >= len(ctx.iterables_corr), G['_il'], ctx.iterables_corr, iterate_idx  
      if iterate_idx >= len(ctx.iterables_corr) or G['_il'] <> ctx.iterables_corr[iterate_idx]:
         if G['_il'] in ctx.iterables_corr: 
            iterate_idx = ctx.iterables_corr.index(G['_il'])
         else:
            iterate_idx = 0
         print "==>", iterate_idx

   iterate_value_vlabel = iterate_vlabel + '_' + ctx.iterables_corr[iterate_idx]
      
   table <= (TR(TD(('Iterate'),align='right') + TD(enum_submit_mod(iterate_vlabel, ctx.iterables, ctx.iterables[iterate_idx]))+TD(),bgcolor=clr(colors,clridx)))
   
   if iterate_idx <> 0:
   
      clrinc()

      if iterate_value_vlabel in REQUEST:
         old_value = REQUEST[iterate_value_vlabel]
      else:
         old_value = ctx.iterables_getter[iterate_idx]()
         
      table <= (TR(TD(('Iterate To'),align='right') + TD(INPUT(name=iterate_value_vlabel,value=old_value))+TD(),bgcolor=clr(colors,clridx)))
      
      clrinc()      
      table <= (TR(TD(('#Iterations'),align='right') + TD(INPUT(name='iteration_steps',value=10))+TD(),bgcolor=clr(colors,clridx)))
      
      G['_iterate_' + entity] = str(iterate_idx)
      G['iterate_object'] = obj
      G['iterate_label'] = ctx.iterables_corr[iterate_idx] 
      G['iterate_name'] = ctx.iterables[iterate_idx]
      G['iteration_getter'] = ctx.iterables_getter[iterate_idx]
      G['iteration_setter'] = ctx.iterables_setter[iterate_idx]
      if iterate_value_vlabel in REQUEST:
         G['iterate_to'] = float(REQUEST[iterate_value_vlabel])  
   
iterate_object = None
iterate_label = '_'

def extlist(lst,size):
    if len(lst) < size:
        lst.extend((size - len(lst)) * [lst[len(lst) - 1]])

def enum(n,e):
    L = SELECT(name = n, onchange="submit();").from_list(e._labels.values())
    L.select(value=e._labels.keys().index(e._value.key()))
    return L
    
def setEnumValueByIdx(e,idx):
    e._value = e._labels.keys()[int(idx)]

def enum_submit_mod(n,names,v):
    L = SELECT(name = n, onchange="submit();").from_list(names)
    L.select(value=names.index(v))
    return L

def enum_submit(n,classes,v):
    names = [x.__name__ for x in classes]
    L = SELECT(name = n, onchange="submit();").from_list(names)
    L.select(value=names.index(v))
    return L

def pricing_options(model_name, family_name):
    return eval('pricings.' + model_name + '.' + model_name + '_' + family_name + '.methods_for_options()').keys()

model_size_mode = False
number_of_companies_mode = False

run_computation = True

if 'a' not in REQUEST:
  _a = 'equity_Black_Scholes_type'

if 'm' not in REQUEST:
  _m = 'BS1D'

if 'f' not in REQUEST:
  _f = 'STD'

if 'o' not in REQUEST:
  _o = 'CallEuro'

if 'meth' not in REQUEST:
  _meth = 'CF_Call'

mod_colors = ['lightgreen','white']
opt_colors = ['#FFFFC0', 'white']
met_colors = ['lightblue','white']
res_colors = ['lightgray', 'white']

def clr(color_table,idx): return color_table[idx%%len(color_table)]

#print assets.asset_models().keys(), "asset_type = ", _asset_type

im = '0'
io = '0'
ip = '0'

changed_iterate = ''

oldit = {'model':0, 'option':0, 'method':0 }

if 'im' in REQUEST: oldit['model'] = int(_im)   
if 'io' in REQUEST: oldit['option'] = int(_io)   
if 'ip' in REQUEST: oldit['method'] = int(_ip)   
            
if 'iterate_model' in REQUEST:
    if _iterate_model <> _im:
        changed_iterate = 'model' 
else:
    _iterate_model = '0'

if 'iterate_option' in REQUEST:
    if _iterate_option <> _io:
        changed_iterate = 'option' 
else:
    _iterate_option = '0'

if 'iterate_method' in REQUEST:
    if _iterate_method <> _ip:
        changed_iterate = 'method' 
else:
    _iterate_method = '0'

computing = 'Compute' in REQUEST

if changed_iterate == 'model':
    _iterate_option = '0'
    _iterate_method = '0' 

if changed_iterate == 'option':
    _iterate_model = '0'
    _iterate_method = '0' 

if changed_iterate == 'method':
    _iterate_option = '0'
    _iterate_model = '0' 

print changed_iterate

g_table = TABLE(Class="content")

g_err_table = TABLE(Class="content")
g_errors = []

def add_error(s): 
    g_err_table <= TR(TD(s), bgcolor='#C00000')
    g_errors.append(s)

table_model = TABLE(Class="content")
table = table_model

if 'asset_type' in REQUEST:
   new_asset_type = assets.all()[int(_asset_type)].__name__
   if _a <> new_asset_type:
      _a = new_asset_type
      _model = 0
      _family = 0
      _option = 0
      _pricing_method = 0
      run_computation = True
      _iterate_model = _iterate_option = _iterate_method = '0' 

table <= (TR(TD((B('Asset Type:')),align='right') + TD(enum_submit('asset_type', assets.all(), _a))+TD(),bgcolor=mod_colors[0]))

clridx = 0

model_list = eval('assets.' + _a + '.models()')

if 'model' in REQUEST:
   new_model = model_list[int(_model)].ID()
   if _m <> new_model:
      _m = new_model
      _family = 0
      _option = 0
      _pricing_method = 0
      run_computation = True
      _iterate_model = _iterate_option = _iterate_method = '0' 

def clrinc():
   globals()['clridx'] = globals()['clridx'] + 1
   
def row(colors, c_1, c_2, c_3=""):
   return (TR(TD(c_1,align='right') + TD(c_2)+TD(c_3),bgcolor=clr(colors,clridx)))

def rowinc(colors, c_1, c_2, c_3=""):
   clrinc()
   return row(colors, c_1, c_2, c_3)

def printModelType(table, model_type):
   table <= rowinc(mod_colors, B('Model:'), enum_submit('model', model_list, model_type))

Include(r'/premia/mod/'+ _m + '/model.py')

table_option = TABLE(Class="content")
table = table_option

if 'family' in REQUEST:
   new_family = model.families()[int(_family)]
   if new_family <> _f:
      _f = new_family
      _option = 0
      _pricing_method = 0
      run_computation = False
      _iterate_option = _iterate_method = '0' 

def printFamilyType(table, family_type):
   table <= rowinc(opt_colors, B('Family:'), enum_submit_mod('family', model.families(), family_type))

if 'option' in REQUEST:
   new_opt = pricing_options(_m,_f)[int(_option)].__name__
   if new_opt <> _o:
      _o = new_opt
      _pricing_method = 0
      run_computation = False
      _iterate_option = _iterate_method = '0' 

def printOptionType(table, option_type):
   table <= rowinc(opt_colors, B('Option:'), enum_submit('option', pricing_options(_m,_f), option_type))

clridx = 1

Include(r'/premia/opt/' + _f + '/' + _o + '.py')

table_method = TABLE(Class="content")
table = table_method

if 'pricing_method' not in REQUEST:
   _pricing_method = '0'
   
methods = [x for x in eval('pricings.' + _m + '.' + _m + '_' + _f + '.all()') if type(opt) in x.options()]
new_meth = methods[int(_pricing_method)].__name__
if _meth <> new_meth:
   _meth = new_meth
   run_computation = False
   _iterate_method = '0' 

clridx = 1

def printMethodType(table, method_type):
   table <= rowinc(met_colors, B('Pricing method:'), enum_submit('pricing_method', methods, method_type))

Include(r'/premia/mod/' + _m + '/' + _m + '_' + _f + '/' + _meth + '.py')


res = None

def n_elem(lst):
    acc = 0
    for i in lst:
        acc += REQUEST.has_key(i)
    return acc

import traceback

if g_errors <> []:
    run_computation = False

if 'Compute' not in REQUEST:
   run_computation = False
   
res_t = None
   
if run_computation and len(REQUEST) > n_elem(['m','f','o','meth',"Model_Size"]):
    try:
        def F(opt,model,q):
            begin = time()
            res = (method(opt,model))
            end = time()
            res.append(("Time", end - begin))
            q.put(res)

        def G(opt,model,q, itobj, itname, itlimit, itcount, itgetter, itsetter):
            initial = itgetter()            
            for i in range(itcount):
                begin = time()
                if itcount > 1:
                    x = initial + 1. * i / (itcount - 1) * (itlimit - initial)
                else:
                    x = initial
                    
                if type(initial) == type(1):
                    x = int(round(x))
                if type(initial) == type(1L):
                    x = long(round(x))
                
                itsetter(x)
                     
                res = (method(opt,model))
                end = time()
                res.insert(0, (itname, x))
                res.append(("Time", end - begin))
                q.put(res)
            
        res = []
        queue = Queue()
        if iterate_object == None:
            process = Process(target = F, args = (opt,model,queue))
        else:
            res_t = []
            process = Process(target = G, args = (opt,model,queue,iterate_object,iterate_name,iterate_to,int(_iteration_steps), iteration_getter, iteration_setter))
        process.start()
        threshold = 10
        try:
            if iterate_object == None:
                res.extend(queue.get(timeout=threshold))
            else:
                begin = time()
                iterations = int(_iteration_steps)
                for i in range(iterations):
                    q = queue.get(timeout=begin + threshold - time())
                    res.extend(q)
                    if res_t == []:
                        for k,v in q:
                            res_t.append((k,[v]))
                    else:
                        idx = 0
                        for k,v in q:
                            assert res_t[idx][0] == k
                            res_t[idx][1].append(v)
                            idx = idx + 1
                    
        except Empty, exc:
            if res == []: res = None
            if res_t == []: res_t = None
            process.terminate()
            raise Exception("Method has worked more than " + str(threshold) + "s. Please try another parameter combination")
            
        process.join(timeout=threshold)
    except Exception, exc:
        print "exception caught:"
        print traceback.format_exc()
        add_error(exc)

table_result_i = TABLE(Class="content")

def script(s):
    print "<script type=\"text/javascript\">"
    print s
    print "</script>"

def todata(v):
   s = "["
   for i in range(len(v)):
      s += "[" + str(res_t[0][1][i]) + "," + str(v[i]) + "],"
   s += "]"
   return s

if res_t <> None:
    script("var datas = []")
    idx = 1
    for k,v in res_t:
        idx = idx + 1
        if type(v[0]) == list:
            table_result_i <= TR(TD(k, align='right',rowspan=len(v[0])) + Sum([TD(L[0]) for L in v]),bgcolor=clr(res_colors,idx))
            if k != res_t[0][0]:               
                script("datas.push({ data : "+todata(map(lambda L: L[0], v))+", label : \'"+k+"[0]\' })")          
            for i in range(1, len(v[0])):
                table_result_i <= TR(Sum([TD(L[i])  for L in v]),bgcolor=clr(res_colors,idx))
                if k != res_t[0][0]:               
                   script("datas.push({ data : "+todata(map(lambda L: L[i], v))+", label : \'"+k+"["+str(i)+"]\' })")          
        else:
            table_result_i <= TR(TD(k,align='right') + Sum([TD(L) for L in v]),bgcolor=clr(res_colors,idx))
            if k != res_t[0][0]:               
               script("datas.push({ data : "+todata(v)+", label : \'"+k+"\' })")          

        

if res_t == None and res <> None:
    idx = 1
    table_method <= TR(TD(B("Result:"),align='right') + TD(B("")))
    for k,v in res:
        idx = idx + 1
        if type(v) == list:
            table_method <= TR(TD(k, align='right',rowspan=len(v)) + TD(v[0]),bgcolor=clr(res_colors,idx))
            for i in range(1, len(v)):
                table_method <= TR(TD(v[i]),bgcolor=clr(res_colors,idx))
        else:
            table_method <= TR(TD(k,align='right') + TD(v),bgcolor=clr(res_colors,idx))

print 'iterate_model = ', _iterate_model
im = str(_iterate_model)
print 'iterate_option = ', _iterate_option
io = str(_iterate_option)
print 'iterate_method = ', _iterate_method
ip = str(_iterate_method)

form = FORM(action='/index?a='+ _a +'&m='+ _m +'&f='+ _f +'&o='+ _o +'&meth=' + _meth+'&im=' + im+'&io=' + io+'&ip=' + ip+'&il='+iterate_label,method="post")

if model_size_mode:
    table_method <= table_model_size_mode
    table_method <= BR()+INPUT(Type="submit",value="Continue")
else:
    table_method <= TR(TD() + TD(INPUT(Type="submit",name="Compute",value="Compute")))
    
if len(g_errors) > 0:
    form <= TR(TD(g_err_table))

g_table <= TR(TD(table_model,valign='top') + TD(table_option,valign='top') + TD(table_method,valign='top'))


form <= g_table

if res_t <> None:
    form <= table_result_i 

print form


if res_t <> None:
    Include('graph.pih') 

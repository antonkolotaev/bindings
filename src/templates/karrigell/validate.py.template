from HTMLTags import *
from Queue import Empty
from multiprocessing import Process,Queue
from time import time

Include('import.py')
Include(r'premia/result_kinds.py')

result_kinds['Time'] = (False,-1)

def checkbox(vname,is_checked=True, is_disabled = False):
   return INPUT(type="checkbox", name=vname, value="1", align="right", checked=is_checked, disabled = is_disabled) 
   
session = Session()


class Ctx:

   def __init__(self):
      self.iterables = ['No iteration']
      self.iterables_corr = ['']
      self.iterables_getter = ['']
      self.iterables_setter = ['']
      self.reload = True
      
Include(r'premia/vector.py')
#Include(r'premia/vector_compact.py')
#Include(r'premia/process_iteration.py')   

def printGraphSerieEx(table, vlabel, friendly, colors, old_checked):
      clrinc()
      
      if 'showGraphLabel_'+vlabel in REQUEST:
         old_label = REQUEST['showGraphLabel_'+vlabel]
      else: 
         old_label = friendly

      enabled = not history_mode or h_iterate_label == iterate_label
         
      table <= TR(TD() + TD(INPUT(name='showGraphLabel_'+vlabel,value=old_label,disabled = not enabled)) + TD(checkbox('showGraph_'+vlabel,old_checked, not enabled)),bgcolor=clr(colors,clridx))

def printGraphSerie(table, vlabel, friendly, colors):
   if 'showGraphLabel_'+vlabel in REQUEST:
      old_checked = 'showGraph_'+vlabel in REQUEST
   else: 
      old_checked = not history_mode
   printGraphSerieEx(table, vlabel, friendly, colors, old_checked)

def printResultSeries(table, results, colors):
   if history_mode:
      if res_labels <> []:
         clrinc()
         table <= TR(TD('Show results in a graph', colspan='3'),bgcolor=clr(colors,clridx))
         #print "RESULTS=", results
         idx = 0
         for i in range(1, len(res_t)):
            vlabel = str(h_idx) + "_" + res_t[i][0]
            if type(res_t[i][1][0]) == list:
               for j in range(len(res_t[i][1][0])):
                  friendly = res_labels[idx][0]
                  idx = idx + 1   
                  printGraphSerie(table, vlabel+str(j), friendly, colors)
            else:
               friendly = res_labels[idx][0]
               idx = idx + 1   
               printGraphSerie(table, vlabel, friendly, colors)
         for (res_hh, res_lh) in res_h:
            for i in range(1, len(res_hh)):
               vlabel = str(h_idx) + "_" + res_hh[i][0]
               friendly = res_lh[i-1]
               printGraphSerie(table, vlabel, friendly, colors)
         
   else:
      if iterate_object <> None: 
         clrinc()
         table <= TR(TD('Show results in a graph', colspan='3'),bgcolor=clr(colors,clridx))
         for (vlabel, friendly) in results:
            printGraphSerieEx(table, vlabel, friendly, colors, result_kinds[vlabel][0])
         printGraphSerieEx(table, 'Time', 'Computation Time', colors, False)

def processIteration(ctx, obj, entity, colors):

   if not history_mode:
      G = globals()
      
      clrinc()
      iterate_vlabel = 'iterate_'+entity
      _iterate_vlabel = '_iterate_'+entity
      
      if _iterate_vlabel in G:
         iterate_idx = int(G[_iterate_vlabel])
      else:
         iterate_idx = 0

      old_idx = G['oldit'][entity]
      #print "old_idx=",old_idx, "iterate_idx=", iterate_idx
      if old_idx == iterate_idx and 'il' in REQUEST and iterate_idx <> 0:
         #print iterate_idx >= len(ctx.iterables_corr), G['_il'], ctx.iterables_corr, iterate_idx  
         if iterate_idx >= len(ctx.iterables_corr) or G['_il'] <> ctx.iterables_corr[iterate_idx]:
            if G['_il'] in ctx.iterables_corr: 
               iterate_idx = ctx.iterables_corr.index(G['_il'])
            else:
               iterate_idx = 0
            #print "==>", iterate_idx

      iterate_value_vlabel = iterate_vlabel + '_' + ctx.iterables_corr[iterate_idx]
         
      table <= (TR(TD(('Iterate'),align='right') + TD(enum_submit_mod(iterate_vlabel, ctx.iterables, ctx.iterables[iterate_idx]))+TD(),bgcolor=clr(colors,clridx)))
      
      if iterate_idx <> 0:
      
         clrinc()

         if iterate_value_vlabel in REQUEST:
            old_value = REQUEST[iterate_value_vlabel]
         else:
            old_value = ctx.iterables_getter[iterate_idx]()
            
         table <= (TR(TD(('Iterate To'),align='right') + TD(INPUT(name=iterate_value_vlabel,value=old_value))+TD(),bgcolor=clr(colors,clridx)))
         
         if 'iteration_steps' in REQUEST:
            steps_no = REQUEST['iteration_steps']
         else:
            steps_no = 10
          
         
         clrinc()      
         table <= (TR(TD(('#Iterations'),align='right') + TD(INPUT(name='iteration_steps',value=steps_no))+TD(),bgcolor=clr(colors,clridx)))
         
         G['_iterate_' + entity] = str(iterate_idx)
         G['iterate_object'] = obj
         G['iterate_label'] = ctx.iterables_corr[iterate_idx] 
         G['iterate_name'] = ctx.iterables[iterate_idx]
         G['iteration_getter'] = ctx.iterables_getter[iterate_idx]
         G['iteration_setter'] = ctx.iterables_setter[iterate_idx]
         if iterate_value_vlabel in REQUEST:
            G['iterate_to'] = float(REQUEST[iterate_value_vlabel])  

#Include(r'premia/scalar.py')

def loadVectorCompact(property_name, vlabel, pmem):
    try:
       if vlabel + '__c' in REQUEST:
         val = float(REQUEST[vlabel + '__c'])
         for i in range(len(pmem)):                 
            pmem[i] = val
       else:
          for i in range(len(pmem)):
             src = vlabel + "[" + str(i) + "]"
             if src in REQUEST: 
                pmem[i] = float(REQUEST[src])
    except Exception, ex:
       add_error('Error in' + property_name + ':' + str(ex))

def processVectorCompact(ctx, table, colors, obj, propname, label, vlabel):
   pmem = getattr(obj, propname)
   clrinc()
   mode = None
   
   if ctx.reload and not history_mode:
      loadVectorCompact(propname, vlabel, pmem)

   if vlabel + '__t' in REQUEST:
      if REQUEST[vlabel + '__t'] == '0':
         mode = 0
      else:
         mode = 1
   else:
      if all(map(lambda x: x == pmem[0], pmem)):
         mode = 0
      else:
         mode = 1

   if not history_mode:
      L = SELECT(name = vlabel+ '__t', onchange='submit();').from_list(['Constant','Array'])
      
   if mode == 0:
      ctx.iterables.append(label)
      ctx.iterables_corr.append(vlabel + '__c')
      ctx.iterables_getter.append(lambda: pmem[0])
      def F(x):
         for i in range(len(pmem)): pmem[i] = x          
      ctx.iterables_setter.append(F)

      if not history_mode:
         L.select(value=0)
         table <= TR(TD(label, align='right',rowspan=2) + TD(L) + TD('',rowspan=2),bgcolor=clr(colors,clridx))
         mc = INPUT(name=vlabel + '__c',value=pmem[0])
         table <= TR(TD(mc),bgcolor=clr(colors,clridx))
      else:
         table <= TR(TD(label, align='right') + TD(pmem[0]) + TD(''),bgcolor=clr(colors,clridx))
            
      

   if mode == 1:
      for i in range(len(pmem)): 
         ctx.iterables.append(label + '[' + str(i) + ']')
         ctx.iterables_corr.append(vlabel + str(i))
      ctx.iterables_getter.extend(map(lambda x: (lambda: x), pmem))
      ctx.iterables_setter.extend(map(lambda i: (lambda z: pmem.__setitem__(i, z)), range(len(pmem))))
   
      if not history_mode:   
         L.select(value=1)
         table <= TR(TD(label, align='right',rowspan=len(pmem)+1) + TD(L) + TD('R',rowspan=len(pmem)+1),bgcolor=clr(colors,clridx))
         table <= Sum([TR(TD(INPUT(name=vlabel + '[' + str(i) + ']',value=pmem[i])),bgcolor=clr(colors,clridx)) for i in range(0,len(pmem))])
      else:
         def as_string(arr):
            s = "["
            for x in arr:
               s += str(x) + ";"
            return s + "]"
         table <= TR(TD(label, align='right') + TD(as_string(pmem)) + TD(''),bgcolor=clr(colors,clridx))

def loadScalar(ctx, property_name, vlabel, obj, conv):
    try:
       if not history_mode and ctx.reload and vlabel in REQUEST:
          setattr(obj, property_name, conv(REQUEST[vlabel]))
    except Exception, ex:
       add_error('Error in '+ property_name +':' + str(ex))

def processScalar(ctx, table, colors, obj, propname, label, vlabel, constr, onChange, iterable, conv):
   loadScalar(ctx, propname, vlabel, obj, conv)
   if not history_mode:
      mc = INPUT(name=vlabel,onchange=onChange,value=getattr(obj, propname))      
   else:
      mc = getattr(obj, propname)
      constr = ''
      
   table <= rowinc(colors, label, mc, constr)
   if iterable:
      ctx.iterables.append(label)
      ctx.iterables_corr.append(vlabel)
      ctx.iterables_getter.append(lambda: getattr(obj, propname))
      ctx.iterables_setter.append(lambda x: setattr(obj, propname, x)) 

   
iterate_object = None
iterate_label = '_'

history_mode = False

def extlist(lst,size):
    if len(lst) < size:
        lst.extend((size - len(lst)) * [lst[len(lst) - 1]])

def enum(n,e):
    L = SELECT(name = n, onchange="submit();").from_list(e._labels.values())
    L.select(value=e._labels.keys().index(e._value.key()))
    return L
    
def setEnumValueByIdx(e,idx):
    e._value = e._labels.keys()[int(idx)]

def enum_submit_mod(n,names,v):
    L = SELECT(name = n, onchange="submit();").from_list(names)
    L.select(value=names.index(v))
    return L

def enum_submit(n,classes,v):
    names = [x.__name__ for x in classes]
    L = SELECT(name = n, onchange="submit();").from_list(names)
    L.select(value=names.index(v))
    return L

def pricing_options(model_name, family_name):
    return eval('pricings.' + model_name + '.' + model_name + '_' + family_name + '.methods_for_options()').keys()

model_size_mode = False
number_of_companies_mode = False

run_computation = True

if 'a' not in REQUEST:
  _a = 'equity_Black_Scholes_type'

if 'm' not in REQUEST:
  _m = 'BS1D'

if 'f' not in REQUEST:
  _f = 'STD'

if 'o' not in REQUEST:
  _o = 'CallEuro'

if 'meth' not in REQUEST:
  _meth = 'CF_Call'

mod_colors = ['lightgreen','white']
opt_colors = ['#FFFFC0', 'white']
met_colors = ['lightblue','white']
res_colors = ['lightgray', 'white']

def clr(color_table,idx): return color_table[idx%%len(color_table)]

#print assets.asset_models().keys(), "asset_type = ", _asset_type

im = '0'
io = '0'
ip = '0'

changed_iterate = ''

oldit = {'model':0, 'option':0, 'method':0 }

if 'im' in REQUEST: oldit['model'] = int(_im)   
if 'io' in REQUEST: oldit['option'] = int(_io)   
if 'ip' in REQUEST: oldit['method'] = int(_ip)   
            
if 'iterate_model' in REQUEST:
    if _iterate_model <> _im:
        changed_iterate = 'model' 
else:
    _iterate_model = '0'

if 'iterate_option' in REQUEST:
    if _iterate_option <> _io:
        changed_iterate = 'option' 
else:
    _iterate_option = '0'

if 'iterate_method' in REQUEST:
    if _iterate_method <> _ip:
        changed_iterate = 'method' 
else:
    _iterate_method = '0'

computing = 'Compute' in REQUEST

if changed_iterate == 'model':
    _iterate_option = '0'
    _iterate_method = '0' 

if changed_iterate == 'option':
    _iterate_model = '0'
    _iterate_method = '0' 

if changed_iterate == 'method':
    _iterate_option = '0'
    _iterate_model = '0' 

#print changed_iterate

g_table = TABLE(Class="content")

g_err_table = TABLE(Class="content")
g_errors = []

def add_error(s): 
    g_err_table <= TR(TD(s), bgcolor='#C00000')
    g_errors.append(s)

table_model = TABLE(Class="content")
table = table_model

if 'asset_type' in REQUEST:
   new_asset_type = assets.all()[int(_asset_type)].__name__
   if _a <> new_asset_type:
      _a = new_asset_type
      _model = 0
      _family = 0
      _option = 0
      _pricing_method = 0
      run_computation = True
      _iterate_model = _iterate_option = _iterate_method = '0' 

def printAsset(table, asset_id):
   if not history_mode:
      mc = enum_submit('asset_type', assets.all(), asset_id)
   else:
      mc = asset_id
   table <= (TR(TD((B('Asset Type:')),align='right') + TD(mc)+TD(),bgcolor=mod_colors[0]))


printAsset(table, _a)

clridx = 0

model_list = eval('assets.' + _a + '.models()')

if 'model' in REQUEST:
   new_model = model_list[int(_model)].ID()
   if _m <> new_model:
      _m = new_model
      _family = 0
      _option = 0
      _pricing_method = 0
      run_computation = True
      _iterate_model = _iterate_option = _iterate_method = '0' 

def clrinc():
   globals()['clridx'] = globals()['clridx'] + 1
   
def row(colors, c_1, c_2, c_3=""):
   return (TR(TD(c_1,align='right') + TD(c_2)+TD(c_3),bgcolor=clr(colors,clridx)))

def rowinc(colors, c_1, c_2, c_3=""):
   clrinc()
   return row(colors, c_1, c_2, c_3)

def printModelType(table, model_type):
   if history_mode:
      mc = model_type
   else:
      mc = enum_submit('model', model_list, model_type)
   table <= rowinc(mod_colors, B('Model:'), mc)

Include(r'/premia/mod/'+ _m + '/model.py')

model = eval('model_' + _m + '(table_model)')

table_option = TABLE(Class="content")
table = table_option

if 'family' in REQUEST:
   new_family = model.families()[int(_family)]
   if new_family <> _f:
      _f = new_family
      _option = 0
      _pricing_method = 0
      run_computation = False
      _iterate_option = _iterate_method = '0' 

def printFamilyType(table, family_type):
   if not history_mode:
      mc = enum_submit_mod('family', model.families(), family_type)
   else:
      mc = family_type
   table <= rowinc(opt_colors, B('Family:'), mc)

if 'option' in REQUEST:
   new_opt = pricing_options(_m,_f)[int(_option)].__name__
   if new_opt <> _o:
      _o = new_opt
      _pricing_method = 0
      run_computation = False
      _iterate_option = _iterate_method = '0' 

def printOptionType(table, option_type):
   if not history_mode:
      mc = enum_submit('option', pricing_options(_m,_f), option_type)
   else:
      mc = option_type
   table <= rowinc(opt_colors, B('Option:'), mc)

clridx = 1

Include(r'/premia/opt/' + _f + '/' + _o + '.py')

opt = eval('opt_' + _f + '_' + _o + '(table_option)')

table_method = TABLE(Class="content")
table = table_method

if 'pricing_method' not in REQUEST:
   _pricing_method = '0'
   
methods = [x for x in eval('pricings.' + _m + '.' + _m + '_' + _f + '.all()') if type(opt) in x.options()]
new_meth = methods[int(_pricing_method)].__name__
if _meth <> new_meth:
   _meth = new_meth
   run_computation = False
   _iterate_method = '0' 

clridx = 1

def printMethodType(table, method_type):
   if not history_mode:
      mc = enum_submit('pricing_method', methods, method_type)
   else:
      mc = method_type
   table <= rowinc(met_colors, B('Pricing method:'), mc)

Include(r'/premia/mod/' + _m + '/' + _m + '_' + _f + '/' + _meth + '.py')

method = eval('method_'+_m+'_'+_f+'_'+_meth+'(table_method)')

res = None

def n_elem(lst):
    acc = 0
    for i in lst:
        acc += REQUEST.has_key(i)
    return acc


table_result_i = TABLE(Class="content")

Include(r'premia/run_computation.py')
#Include(r'premia/print_table_result.py')
def script(s):
   """
    print "<script type=\"text/javascript\">"
    print s
    print "</script>"
   """
   return SCRIPT(s, type=r"text/javascript")

def todata(header, v):
   s = "["
   for i in range(len(v)):
      s += "[" + str(header[i]) + "," + str(v[i]) + "],"
   s += "]"
   return s

#print REQUEST

datas = {}

def corrected(s):
   r = ""
   for c in s:
      if c.isalnum():
         r += c
      else:
         r += '_'
   return r

result_labels = []
def printVectorResult(table_result_i, res_t):
    table_result_i <= script("var datas = []")
    idx = 1
    res_h = []
    for k,v in res_t:
        idx = idx + 1
        is_header = k == res_t[0][0]
        is_selected = ('showGraph_' + k in REQUEST)
  
        if not is_header and is_selected:
           kind = result_kinds[k][1]
           if kind not in datas: datas[kind] = []

        if type(v[0]) == list:

            table_result_i <= TR(TD(k, align='right',rowspan=len(v[0])) + Sum([TD(L[0]) for L in v]),bgcolor=clr(res_colors,idx))

            if not is_header:
               result_labels.extend(map(lambda i: (REQUEST['showGraphLabel_' + k]+"["+str(i)+"]", ('showGraph_' + k in REQUEST)), range(len(v[0]))))          
            
            if not is_header and is_selected:               
                #table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], map(lambda L: L[0], v))+", label : \'"+REQUEST['showGraphLabel_' + k]+"[0]\' })")
                datas[kind].append(("\'"+REQUEST['showGraphLabel_' + k]+"[0]\'", todata(res_t[0][1], map(lambda L: L[0], v))))    
            for i in range(1, len(v[0])):
                table_result_i <= TR(Sum([TD(L[i])  for L in v]),bgcolor=clr(res_colors,idx))
                if not is_header and is_selected:               
                   #table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], map(lambda L: L[i], v))+", label : \'"+REQUEST['showGraphLabel_' + k]+"["+str(i)+"]\' })")          
                   datas[kind].append(("\'"+REQUEST['showGraphLabel_' + k]+"["+str(i)+"]\'", todata(res_t[0][1], map(lambda L: L[i], v))))    
        else:
            table_result_i <= TR(TD(k,align='right') + Sum([TD(L) for L in v]),bgcolor=clr(res_colors,idx))
            if not is_header:
               result_labels.append((REQUEST['showGraphLabel_' + k], ('showGraph_' + k in REQUEST)))
               
            if not is_header and is_selected:               
               #table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], v)+", label : \'"+REQUEST['showGraphLabel_' + k]+"\' })")          
               datas[kind].append(("\'"+REQUEST['showGraphLabel_' + k]+"\'", todata(res_t[0][1], v)))    

    for hh_idx in range(len(session.history)):
      h_idx = len(session.history) - hh_idx - 1
      h = session.history[h_idx]
      h_results = h[6]
      h_iterate_label = h[7]
      if h_results <> None and h_iterate_label == iterate_label:
         res_hh = []
         res_lh = []
         for i in range(len(h_results)):
            hk,hv = h_results[i]
            
            if i <> 0:
               kind = result_kinds[hk][1]
               if kind not in datas: datas[kind] = []
  
            if type(hv[0]) == list:
               for j in range(len(hv[0])):
                  vlabel = str(h_idx) + "_" + hk + str(j)
                  if 'showGraph_'+vlabel in REQUEST:

                     if res_hh == []:
                           res_hh = [h_results[0]]

                     res_hh.append((hk+"_"+str(h_idx), map(lambda x: x[j], hv)))
                     res_lh.append(REQUEST['showGraphLabel_'+ vlabel])

                     #table_result_i <= script("datas.push({ data : "+todata(h_results[0][1], map(lambda L: L[j], hv))+", label : \'"+REQUEST['showGraphLabel_' + vlabel]+"\' })")          
                     datas[kind].append(("\'"+REQUEST['showGraphLabel_' + vlabel]+"\'", todata(h_results[0][1], map(lambda L: L[j], hv))))    
            else:
               vlabel = str(h_idx) + "_" + hk
            
               if 'showGraph_'+vlabel in REQUEST:
                 
                  if res_hh == []:
                        res_hh = [h_results[0]]
                    
                  res_hh.append((hk+"_"+str(h_idx), hv))
                  res_lh.append(REQUEST['showGraphLabel_'+ vlabel])
                     
                  ddd = todata(h_results[0][1], hv)
                  #table_result_i <= script("datas.push({ data : "+ddd+", label : \'"+REQUEST['showGraphLabel_' + vlabel]+"\' })")          
                  datas[kind].append(("\'"+REQUEST['showGraphLabel_' + vlabel]+"\'", ddd))    
         
         if res_hh <> []: res_h.append((res_hh, res_lh))
    #print res_h
    return res_h

Include(r'premia/print_scalar_result.py')        

if res_t == None and res <> None:
   printScalarResult(table_method, res)

res_h = []
if res_t <> None:
   res_h = printVectorResult(table_result_i, res_t)
   
#print 'iterate_model = ', _iterate_model
im = str(_iterate_model)
#print 'iterate_option = ', _iterate_option
io = str(_iterate_option)
#print 'iterate_method = ', _iterate_method
ip = str(_iterate_method)

form = FORM(action='/index?a='+ _a +'&m='+ _m +'&f='+ _f +'&o='+ _o +'&meth=' + _meth+'&im=' + im+'&io=' + io+'&ip=' + ip+'&il='+iterate_label,method="post")

if model_size_mode:
    table_method <= table_model_size_mode
    table_method <= BR()+INPUT(Type="submit",value="Continue")
else:
    table_method <= TR(TD() + TD(INPUT(Type="submit",name="Compute",value="Compute")))
    
if len(g_errors) > 0:
    form <= TR(TD(g_err_table))

g_table <= TR(TD(table_model,valign='top') + TD(table_option,valign='top') + TD(table_method,valign='top'))

if 'history' not in dir(session):
   session.history = []


if 'ClearHistory' in REQUEST:
   session.history = []
   
form <= g_table


if res_t <> None:
   form <= table_result_i 

graph_t = """
  <head>
  </head>
  <body>
    <style type="text/css">
      body {
        margin: 0px;
        padding: 0px;
      }
      #qqq {
        width : 600px;
        height: 384px;
        margin: 8px auto;
      }
    </style>
  <table>
   <tr>
      <td>
         <div id="qqq">
      </td>
   </tr>
  </table>
    <!--[if lt IE 9]>
    <script type="text/javascript" src="flashcanvas.js"></script>
    <![endif]-->
    <script type="text/javascript" src="premia/flotr2.min.js"></script>
    <script type="text/javascript">
(function basic_legend(container) {

  var
    graph;


  function labelFn (label) {
    return label;
  }

  // Draw graph
  graph = Flotr.draw(container, datas, {
    legend : {
      position : 'se',            // Position the legend 'south-east'.
      labelFormatter : labelFn,   // Format the labels.
      backgroundColor : '#D2E8FF' // A light blue background color.
    },
    HtmlText : false
  });
})(document.getElementById('qqq'));      
    </script>
  </body>
"""

if res_t <> None:
    values = datas.values()
    for i in range(len(values)):
        form <= script("data"+str(i)+" = [];")
        for label, sc in values[i]:
            form <= script("data"+str(i)+".push({ data : "+sc+", label : "+label+" });")          
        if values[i] <> []:
           form <= TEXT(graph_t.replace('qqq','containers' + str(i)).replace("datas", "data"+str(i)))

history_mode = True

#print form

if 'result_labels' not in dir():
   result_labels = [] 

to_save = None

if res_t <> None or res <> None:   
   to_save = (_a, model, opt, method, result_labels, res, res_t, iterate_label, res_h)

#print REQUEST

def printVectorHistoryResult(table_result_i, res_t, res_labels): #ddd
    idx = 1
    rli = -1
    
    #print res_labels
    
    for k,v in res_t:
        idx = idx + 1
        is_header = k == res_t[0][0]

        if type(v[0]) == list:

            table_result_i <= TR(TD(k, align='right',rowspan=len(v[0])) + Sum([TD(L[0]) for L in v]),bgcolor=clr(res_colors,idx))
            
            if res_labels[rli][1]:               
            
                table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], map(lambda L: L[0], v))+", label : \'"+res_labels[rli][0]+"\' })")
            
            rli = rli + 1
                
            for i in range(1, len(v[0])):
                table_result_i <= TR(Sum([TD(L[i])  for L in v]),bgcolor=clr(res_colors,idx))
    
                if res_labels[rli][1]:               
                   table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], map(lambda L: L[i], v))+", label : \'"+ res_labels[rli][0]  +"\' })")         
                rli = rli + 1 
        else:
            table_result_i <= TR(TD(k,align='right') + Sum([TD(L) for L in v]),bgcolor=clr(res_colors,idx))
               
            if not is_header and res_labels[rli][1]:               
               table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], v)+", label : \'"+res_labels[rli][0]+"\' })")        
            rli = rli + 1  

if to_save <> None:
   session.history.append(to_save)

if session.history <> []:
   form <= INPUT(Type="submit",name="ClearHistory",value="Clear history")

for hh_idx in range(len(session.history)):

   h_idx = len(session.history) - hh_idx - 1
   h = session.history[h_idx]

   g_table = TABLE(Class="content")

   table_model_h = TABLE(Class="content")
   table_opt_h = TABLE(Class="content")
   table_meth_h = TABLE(Class="content")

   asset_id = h[0]
   printAsset(table_model_h, asset_id)
   model_list = eval('assets.' + asset_id + '.models()')

   model = h[1]
   Include(r'/premia/mod/'+ model.ID() + '/model.py')
   eval('model_' + model.ID() + '(table_model_h, model)')

   opt = h[2]
   Include(r'/premia/opt/' + opt.familyName() + r'/' + type(opt).__name__ + '.py')
   opt = eval('opt_' + opt.familyName() + '_' + type(opt).__name__ + '(table_opt_h, opt)')

   method = h[3]
   res_labels = h[4]
   res = h[5]
   res_t = h[6]
   h_iterate_label = h[7]
   res_h = h[8]
   
   #print h_idx, res_labels

   Include(r'/premia/mod/' + model.ID() + '/' + model.ID() + '_' + opt.familyName() + '/' + type(method).__name__ + '.py')
   method = eval('method_'+model.ID()+'_'+opt.familyName()+'_'+type(method).__name__+'(table_meth_h, method)')
   
   if res_t == None and res <> None:
      printScalarResult(table_meth_h, res)

   g_table <= TR(TD(table_model_h,valign='top')+TD(table_opt_h,valign='top')+TD(table_meth_h,valign='top'))

   form <= g_table

   form <= script("var datas = []")

   if res_t <> None:
      table_result_h = TABLE(Class="content")
      printVectorHistoryResult(table_result_h, res_t, res_labels)
      form <= table_result_h
   
   for (res_hh, res_lh) in res_h:
      res_hf = [(l,True) for l in res_lh]
      table_result_h = TABLE(Class="content")
      printVectorHistoryResult(table_result_h, res_hh, res_hf)
      form <= table_result_h
   
   if res_t <> None or res_h <> []:
       qqq = 'container' + str(h_idx)
       #Include(r'premia/graph.pih') 
       form <= TEXT(graph_t.replace('qqq',qqq))

print form



from HTMLTags import *
from Queue import Empty
from multiprocessing import Process,Queue
from time import time
from copy import copy

saved_REQUEST = copy(REQUEST)

Include('import.py')
#Include(r'premia/result_kinds.py')

from kspremia.result_kinds import *
from kspremia import enum
from kspremia import vector
from kspremia import vector_compact
from kspremia import scalar

class cached_property(object):
    '''A read-only @property that is only evaluated once. The value is cached
    on the object itself rather than the function or class; this should prevent
    memory leakage.'''
    def __init__(self, fget, doc=None):
        self.fget = fget
        self.__doc__ = doc or fget.__doc__
        self.__name__ = fget.__name__
        self.__module__ = fget.__module__

    def __get__(self, obj, cls):
        if obj is None:
            return self
        obj.__dict__[self.__name__] = result = self.fget(obj)
        return result


# object defining per-user data   
session = Session()

# Type: corrected_output_parameter_name : string
# -> (should_it_be_in_graph_by_default : bool, its_kind_id : int)
# here we just add a 'Time' output parameter which is not show by default
result_kinds['Time'] = (False,-1)

# Type: int optional
# if not None, indicates that for current state we should take history-th element of history
history = None

# some tuple representing current history element if any
# TODO: replaced by class
history_obj = None

# if 'history' is in URI, we are in history mode
if '_history' in dir():
   history = int(_history)
   history_obj = session.history[history]

def checkbox(vname,checked=True, disabled = False):
   """
   Returns a checkbox with given name
   checked - is the checkbox checked
   disabled - is the checkbox disabled 
   """
   return INPUT(type="checkbox", 
                name=vname, 
                value="1", 
                align="right", 
                checked=checked, 
                disabled = disabled) 
   
"""
ModelIteration: (same for Option and Method iteration)
   - list of iterable field names: idx -> printable_name
   - function to get iterable field corrected names by its index: idx -> corrected_name
   - function to get iterable field getter by its index: idx -> (() -> FieldValue)
   - function to get iterable field setter by its index: idx -> (FieldValue -> ()) 
"""


# This class contains arrays representing possible iteration over some entity parameter
# All the arrays have the first element corresponding to No Iteration case
# Following elemenets represent data for iterable entity parameters
# If a parameter is of PNLVECT type of size N, these array contain N its components
# If a parameter is of PNLVECTCOMPACT type of size N, 
#     these array contain N its components if it is heterogenous, or 1 component if homogenous
# If a parameter if ENUM type, its parameters, if any, appear in these arrays 
# _iterables  - printable labels for iterable parameters. Type: string list
# _iterables_corr - corrected names for variables. Type: string list
# _iterables_getter - functions returning parameter's value from the entity.
#                    Type: list<() -> (int | double)>
# _iterables_setter - functions setting parameter's value in the entity.
#                    Type: list<(int | double) -> ()>
# TODO: introduce IterableParam class
# reload : bool  - flag showing should we try to load entity params from the form sent
class Iterables:

   def __init__(self, parent):
      # 
      self._iterables = ['No iteration']
      self._iterables_corr = ['']
      self._iterables_getter = ['']
      self._iterables_setter = ['']
      self._iterables = ['No iteration']
      self.reload = True
      self.parent = parent
      
   def __len__(self): return len(self._iterables)
      
   @property
   def entity(self):
      return self.parent.entity
  
   @property
   def labels(self):
      return self._iterables
      
   def checkIdx(self, idx):
      assert 0 <= idx and idx < len(self._iterables_corr)
      
   def getCorrectedName(self, idx):
      self.checkIdx(idx)
      return self._iterables_corr[idx]
      
   def lookupByCorrectedName(self, correctedName):
      if correctedName in self._iterables_corr: 
         return self._iterables_corr.index(correctedName)
      else:
         return 0
   
      
   def getGetter(self, idx):
      self.checkIdx(idx)
      return self._iterables_getter[idx]

   def getSetter(self, idx):
      self.checkIdx(idx)
      return self._iterables_setter[idx]
 

# Depends on:
#   - clrinc, clridx
#   - REQUEST
#   - history_mode
#   - h_iterate_label 
#   - iterate_label
def printGraphSerieEx(table, vlabel, friendly, colors, old_checked):
      """
      Adds a row corresponding to a result parameter to the 'show graph' table 
      asking a user should a graph for this parameter be built
       
      table : HTMLTable - target table
      vlabel : string - corrected name of the result parameter
      friendly : string - original name of the result parameter
      colors - color array to pickup the color for the row (TBD: refactor)
      old_checked : bool - initial state of the checkbox
      """
      clrinc()
      
      # if user changed label for the result parameter to be shown on the graph
      # we'll use it
      if 'showGraphLabel_'+vlabel in REQUEST:
         old_label = REQUEST['showGraphLabel_'+vlabel]
      else: 
         old_label = friendly

      # we may ask the user only if this history iteration of this 
      # is compatible with current iteration  
      enabled = not history_mode or h_iterate_label == state.iterationLabel
         
      table <= TR(
                  TD() + 
                  TD( # input box to enter label for this graph serie
                     INPUT(name='showGraphLabel_'+vlabel,
                           value=old_label,
                           disabled = not enabled)) + 
                  TD( # check box should be this serie shown on the graph
                     checkbox('showGraph_'+vlabel,
                              checked = old_checked, 
                              disabled = not enabled)),
                  bgcolor=clr(colors,clridx))

# depends on:
#   - REQUEST
#   - history_mode
# printGraphSerieEx with defined old_checked
def printGraphSerie(table, vlabel, friendly, colors):
   if 'showGraphLabel_'+vlabel in REQUEST:
      old_checked = 'showGraph_'+vlabel in REQUEST
   else: 
      old_checked = not history_mode
   printGraphSerieEx(table, vlabel, friendly, colors, old_checked)

# Depends on:
#  - res_labels
#  - clrinc
#  - h_idx
#  - res_t
#  - res_h 

# prints a table asking which parameters are to be shown on graph 
# and which names should they have
# table : HTMLTable -- table to add rows with result parameters 
# results : (vlabel, friendly) seq -- in history mode represents output parameters for the method
# colors -- colors array
def printResultSeries(table, results, colors):
   if history_mode:
      # TODO: ???
      # this code is not really useful. should be removed
      if res_labels <> []:    # it seems to me that res_labels contains 
                              #  old flattened labels for result series 
         clrinc()
         table <= TR(TD('Show results in a graph', colspan='3'),bgcolor=clr(colors,clridx))

         idx = 0  # flattened index of the output parameter being processed
         for i in range(1, len(res_t)): # iterating current table results
            vlabel = str(h_idx) + "_" + res_t[i][0]   # base for variable name
            if type(res_t[i][1][0]) == list:          # if output param is list
               for j in range(len(res_t[i][1][0])):   # for every component of ????
                  friendly = res_labels[idx][0]
                  idx = idx + 1   
                  printGraphSerie(table, vlabel+str(j), friendly, colors)
            else:
               friendly = res_labels[idx][0]
               idx = idx + 1   
               printGraphSerie(table, vlabel, friendly, colors)

         for (res_hh, res_lh) in res_h:   # res_h is graph series for some elder run
            for i in range(1, len(res_hh)):
               vlabel = str(h_idx) + "_" + res_hh[i][0]
               friendly = res_lh[i-1]
               printGraphSerie(table, vlabel, friendly, colors)
         
   else: # case of the current view
      if state.iteration <> None: 
         clrinc()
         table <= TR(TD('Show results in a graph', colspan='3'),bgcolor=clr(colors,clridx))
         for (vlabel, friendly) in results:
            printGraphSerieEx(table, vlabel, friendly, colors, result_kinds[vlabel][0])
         printGraphSerieEx(table, 'Time', 'Computation Time', colors, False)

class IterationState(object):

   def __init__(self, obj, iterables, idx, iterateTo, stepsNo):
      self.obj = obj
      self.idx = idx
      self.label = iterables.getCorrectedName(idx) 
      self.name = iterables.labels[idx]
      self.getter = iterables.getGetter(idx)
      self.setter = iterables.getSetter(idx)
      self.iterateTo = iterateTo
      self.stepsNo = stepsNo


# Depends on:
#  - colors
#  - globals

#def processIteration(ctx, obj, entity, colors):
def processIteration(state):

   ctx = state.iterables
   obj = state.obj
   entity = state.entityLabel
   colors = state.colors
   table = state.table

   if not history_mode:
      G = globals()
      
      clrinc()
      # obtaining name of the variable containing iteration index for 'entity'
      iterate_vlabel = state.iterateVlabel
      _iterate_vlabel = '_iterate_'+entity   
      
      # getting iteration index for 'entity'
      #if _iterate_vlabel in G:   
      #   iterate_idx = int(G[_iterate_vlabel])
      #else:
      #   iterate_idx = 0


      #old_idx = G['oldit'][entity]

      iterate_idx = state.iterationIdx
      old_idx = state.oldIterationIdx

      iterationLabel = state.iterationLabel
      """
      if state.oldIterationIdx == state.iterationIdx and state.iterationLabel <> None and state.iterationIdx <> 0:
         if state.iterationIdx >= len(state.iterables) or state.iterationLabel <> state.iterables.getCorrectedName(state.iterationIdx):
            iterate_idx = state.iterables.lookupByCorrectedName(state.iterationLabel)
      """

      iterate_idx = state.fixedIterationIdx

      iterate_value_vlabel = state.iterateValueVlabel
         
      table <= (TR(TD(('Iterate'),align='right') + TD(enum_submit_mod(iterate_vlabel, ctx.labels, ctx.labels[iterate_idx]))+TD(),bgcolor=clr(colors,clridx)))
      
      if iterate_idx <> 0:
      
         clrinc()

         old_value = state.oldIterationValue
         
         """
         if iterate_value_vlabel in REQUEST:
            old_value = REQUEST[iterate_value_vlabel]
         else:
            old_value = ctx.getGetter(iterate_idx)()
         """

         table <= (TR(TD(('Iterate To'),align='right') + TD(INPUT(name=iterate_value_vlabel,value=old_value))+TD(),bgcolor=clr(colors,clridx)))
         
         """
         if 'iteration_steps' in REQUEST:
            steps_no = REQUEST['iteration_steps']
         else:
            steps_no = 10
         """

         steps_no = state.iterationStepNumber 
         
         clrinc()      
         table <= (TR(TD(('#Iterations'),align='right') + TD(INPUT(name='iteration_steps',value=steps_no))+TD(),bgcolor=clr(colors,clridx)))
         
         #G['_iterate_' + entity] = str(iterate_idx)
         #G['iterate_object'] = obj
         #G['iterate_label'] = ctx.getCorrectedName(iterate_idx) 
         #G['iterate_name'] = ctx.labels[iterate_idx]
         #G['iteration_getter'] = ctx.getGetter(iterate_idx)
         #G['iteration_setter'] = ctx.getSetter(iterate_idx)
         #if iterate_value_vlabel in REQUEST:
         #   G['iterate_to'] = float(REQUEST[iterate_value_vlabel])  

class VisitorBase(object):

   def __init__(self):
      self.history_mode = history_mode

   def addError(self, msg): add_error(msg)


class Loader(VisitorBase):

   def __init__(self):
      VisitorBase.__init__(self)
      self.REQUEST = REQUEST
      self.reload = True
      
   def enumVisitor(self): return EnumLoader   

   def get(self, key, func):
      if key in self.REQUEST:
         func(self.REQUEST[key])
         return True
      else:
         return False
      
   def process(self, field):  
      try:
         if not self.history_mode and self.reload:
            field.load(self)
      except Exception, ex:
         v.addError('Error in '+ field.propertyName +':' + str(ex))

class EntityTable(TABLE):

   def __init__(self, colors):
      TABLE.__init__(self, Class="content")
      self.colors = colors
      self.clridx = 0

   def clrinc(self): 
      self.clridx = self.clridx + 1
      if self.clridx >= len(self.colors):
         self.clridx = 0

   @property
   def currentColor(self): 
      return self.colors[self.clridx]

   def row(self, c1, c2, c3=''):
      self.clrinc()   
      self     <= (TR(
                     TD(c1,align='right') + 
                     TD(c2)+
                     TD(c3),
                     bgcolor=self.currentColor
                     )) 

   def spannedRows(self, c1, c2s, c3=''):
      self.clrinc()
      self       <= TR(TD(c1, align='right',rowspan=len(c2s)) + 
                       TD(c2s[0]) + 
                       TD(c3, rowspan=len(c2s)),
                       bgcolor=self.currentColor)
               
      self       <= Sum([TR(TD(c2s[i]), bgcolor=self.currentColor) for i in range(1,len(c2s))])

class Renderer(VisitorBase):

   def __init__(self, table, colors):
      VisitorBase.__init__(self)
      self.table = table
      self.colors = colors
      
   def clrinc(self): clrinc()
   @property
   def currentColor(self): return clr(self.colors,clridx)
   
   def process(self, field):  
      if not self.history_mode:
         field.render(self)
      else:
         field.renderHistory(self)

   def enumVisitor(self): return EnumRenderer

   def row(self, c1, c2, c3=''):
      self.clrinc()   
      self.table <= (TR(
                     TD(c1,align='right') + 
                     TD(c2)+
                     TD(c3),
                     bgcolor=self.currentColor
                     )) 

   def spannedRows(self, c1, c2s, c3=''):
      self.clrinc()
      self.table <= TR(TD(c1, align='right',rowspan=len(c2s)) + 
                       TD(c2s[0]) + 
                       TD(c3, rowspan=len(c2s)),
                       bgcolor=self.currentColor)
               
      self.table <= Sum([TR(TD(c2s[i]), bgcolor=self.currentColor) for i in range(1,len(c2s))])

class HistoricalRenderer(Renderer):

   def __init__(self, table, colors):
      Renderer.__init__(self, table, colors)
        
   def enumVisitor(self): return EnumHistoricalRenderer
 
class IterablesExtractor(VisitorBase):

   def __init__(self):
      VisitorBase.__init__(self)
      self.ctx = Iterables(self)
      
   def addError(self, msg): add_error(msg)
      
   def process(self, field):  field.getIterables(self)

   def enumVisitor(self): return EnumIterablesExtractor   
         
class EnumLoader(Loader):

   def __init__(self, source, member):
      super(EnumLoader,self).__init__()
      self.member = member
      
   def setLabels(self, label, vlabel, labels, has_params):
   
      if vlabel not in self.REQUEST:
         self.REQUEST[vlabel] = '0'
      
      if self.history_mode:
         e = labels.index(self.member._labels[self.member._value.key()])
      else:
         e = int(self.REQUEST[vlabel])
         
      return e
   
   def setChoice(self, setter):
   
      setter(self.member)
   
   @property
   def entity(self):
      return self.member._value

class EnumRenderer(Renderer):

   def __init__(self, source, member):
      super(EnumRenderer, self).__init__(source.table, source.colors)
      self.member = member
      
   def setLabels(self, label, vlabel, labels, has_params):
   
      e = labels.index(self.member._labels[self.member._value.key()])
         
      if has_params:
         L = SELECT(name = vlabel, onchange='submit();').from_list(labels)
      else:
         L = SELECT(name = vlabel).from_list(labels)
         
      L.select(value=e)
      
      self.row(label, L)
      
      return e
   
   def setChoice(self, setter):   
      pass
   
   @property
   def entity(self):
      return self.member._value

class EnumHistoricalRenderer(HistoricalRenderer):

   def __init__(self, source, member):
      HistoricalRenderer.__init__(self, source.table, source.colors)
      self.member = member
      
   def setLabels(self, label, vlabel, labels, has_params):
   
      e = labels.index(self.member._labels[self.member._value.key()])
         
      self.row(label, labels[e])
      
      return e
   
   def setChoice(self, setter):   
      pass
   
   @property
   def entity(self):
      return self.member._value
   
class EnumIterablesExtractor(IterablesExtractor):

   def __init__(self, source, member):
      super(EnumIterablesExtractor, self).__init__()
      self.ctx = source.ctx
      self.member = member
      
   def setLabels(self, label, vlabel, labels, has_params):
      e = labels.index(self.member._labels[self.member._value.key()])
      return e
   
   def setChoice(self, setter):
      pass
    
   @property
   def entity(self):
      return self.member._value

class ModelVisitorBase(object):

   def __init__(self, model=None):
      self.model = model  
   
   @property
   def entity(self):
      return self.model   
      
   @property
   def entityLabel(self):
      return 'model'   

class ModelLoader(Loader, ModelVisitorBase):

   def __init__(self, state):
      Loader.__init__(self)
      ModelVisitorBase.__init__(self, None)

   def setModel(self, modelFactory, modelName):
      if self.model == None: 
         self.model = modelFactory()

class ModelRenderer(Renderer, ModelVisitorBase):

   def __init__(self, state):
      Renderer.__init__(self, state.assetTable, mod_colors)
      self.state = state
      ModelVisitorBase.__init__(self, state.obj)
   
   def setModel(self, modelFactory, modelName):
      mc = enum_submit('model', self.state.models, modelName)
      self.row(B('Model:'), mc)
                   
class ModelHistoricalRenderer(HistoricalRenderer, ModelVisitorBase):

   def __init__(self, table, model=None):
      HistoricalRenderer.__init__(self, table, mod_colors)
      ModelVisitorBase.__init__(self, model)
   
   def setModel(self, modelFactory, modelName):
      self.row(B('Model:'), modelName)                   

class ModelIterablesExtractor(IterablesExtractor, ModelVisitorBase):

   def __init__(self, state):
      IterablesExtractor.__init__(self)
      ModelVisitorBase.__init__(self, state.obj)
   
   def setModel(self, modelFactory, modelName):
      pass

class OptionVisitorBase(object):

   def __init__(self, option=None):
      self.option = option  
   
   @property
   def entity(self):
      return self.option   
      
   @property
   def entityLabel(self):
      return 'option'   

class OptionLoader(Loader, OptionVisitorBase):

   def __init__(self, state):
      Loader.__init__(self)
      OptionVisitorBase.__init__(self, None)
      
   def setOption(self, optionFactory, familyName, optionName):
      
      if self.option == None:
         self.option = optionFactory()

class OptionRenderer(Renderer, OptionVisitorBase):

   def __init__(self, state):
      Renderer.__init__(self, state.parent.family.table, opt_colors)
      OptionVisitorBase.__init__(self,state.obj)
      self.state = state
      
   def setOption(self, optionFactory, familyName, optionName):
      rc = enum_submit('option', self.state.options, optionName)
      self.row(B('Option:'), rc)

class OptionHistoricalRenderer(HistoricalRenderer, OptionVisitorBase):

   def __init__(self, table, option=None):
      HistoricalRenderer.__init__(self, table, opt_colors)
      OptionVisitorBase.__init__(self,option)
      
   def setOption(self, optionFactory, familyName, optionName):
      self.row(B('Family:'), familyName)
      self.row(B('Option:'), optionName)
            
class OptionIterablesExtractor(IterablesExtractor, OptionVisitorBase):

   def __init__(self, state):
      IterablesExtractor.__init__(self)
      OptionVisitorBase.__init__(self, state.obj)
      
   def setOption(self, optionFactory, familyName, optionName):
      pass

class MethodVisitorBase(object):

   def __init__(self, method=None):
      self.method = method  
      self.reload = run_computation
   
   @property
   def entity(self):
      return self.method   
      
   @property
   def entityLabel(self):
      return 'method'  

   def setMethod(self, methodFactory, methodName):
      pass
      
   def printResultSeries(self, result_members):
      pass


      
class MethodLoader(Loader, MethodVisitorBase):

   def __init__(self, state):
      Loader.__init__(self)
      MethodVisitorBase.__init__(self, None)

   def setMethod(self, methodFactory, methodName):
      if self.method == None: 
         self.method = methodFactory()

 
class MethodRenderer(Renderer, MethodVisitorBase):

   def __init__(self, state):
      Renderer.__init__(self, state.origTable, met_colors)
      MethodVisitorBase.__init__(self, state.obj)
      self.state = state

   def setMethod(self, methodFactory, methodName):
      self.row(B('Pricing method:'), enum_submit('pricing_method', self.state.methods, methodName))

   def printResultSeries(self, result_members):
      pass
      #printResultSeries(self.table, result_members, self.colors)

class MethodHistoricalRenderer(HistoricalRenderer, MethodVisitorBase):

   def __init__(self, table, method=None):
      HistoricalRenderer.__init__(self, table, met_colors)
      MethodVisitorBase.__init__(self, method)

   def setMethod(self, methodFactory, methodName):
      self.row(B('Pricing method:'), methodName)

   def printResultSeries(self, result_members):
      printResultSeries(self.table, result_members, self.colors)


class MethodIterablesExtractor(IterablesExtractor, MethodVisitorBase):

   def __init__(self, state):
      IterablesExtractor.__init__(self)
      MethodVisitorBase.__init__(self, state.obj)


#iterate_label = '_'

history_mode = False

def extlist(lst,size):
    if len(lst) < size:
        lst.extend((size - len(lst)) * [lst[len(lst) - 1]])

def enum(n,e):
    L = SELECT(name = n, onchange="submit();").from_list(e._labels.values())
    L.select(value=e._labels.keys().index(e._value.key()))
    return L
    
def setEnumValueByIdx(e,idx):
    e._value = e._labels.keys()[int(idx)]

def enum_submit_mod(n,names,v):
    L = SELECT(name = n, onchange="submit();").from_list(names)
    L.select(value=names.index(v))
    return L

def enum_submit(n,classes,v):
    names = [x.__name__ for x in classes]
    L = SELECT(name = n, onchange="submit();").from_list(names)
    L.select(value=names.index(v))
    return L

def pricing_options(model_name, family_name):
    return eval('pricings.' + model_name + '.' + model_name + '_' + family_name + '.methods_for_options()').keys()

model_size_mode = False
number_of_companies_mode = False

run_computation = True

if 'a' not in REQUEST:
  _a = 'equity_Black_Scholes_type'

if 'm' not in REQUEST:
  _m = 'BS1D'

if 'f' not in REQUEST:
  _f = 'STD'

if 'o' not in REQUEST:
  _o = 'CallEuro'

if 'meth' not in REQUEST:
  _meth = 'CF_Call'

mod_colors = ['lightgreen','white']
opt_colors = ['#FFFFC0', 'white']
met_colors = ['lightblue','white']
res_colors = ['lightgray', 'white']

def clr(color_table,idx): return color_table[idx%%len(color_table)]

#print assets.asset_models().keys(), "asset_type = ", _asset_type

im = '0'
io = '0'
ip = '0'

changed_iterate = ''

oldit = {'model':0, 'option':0, 'method':0 }

if 'im' in REQUEST: oldit['model'] = int(_im)   
if 'io' in REQUEST: oldit['option'] = int(_io)   
if 'ip' in REQUEST: oldit['method'] = int(_ip)   
            
if 'iterate_model' in REQUEST:
    if _iterate_model <> _im:
        changed_iterate = 'model' 
else:
    _iterate_model = '0'

if 'iterate_option' in REQUEST:
    if _iterate_option <> _io:
        changed_iterate = 'option' 
else:
    _iterate_option = '0'

if 'iterate_method' in REQUEST:
    if _iterate_method <> _ip:
        changed_iterate = 'method' 
else:
    _iterate_method = '0'

computing = 'Compute' in REQUEST

if changed_iterate == 'model':
    _iterate_option = '0'
    _iterate_method = '0' 

if changed_iterate == 'option':
    _iterate_model = '0'
    _iterate_method = '0' 

if changed_iterate == 'method':
    _iterate_option = '0'
    _iterate_model = '0' 

#print changed_iterate

g_table = TABLE(Class="content")

g_err_table = TABLE(Class="content")
g_errors = []

def add_error(s): 
    g_err_table <= TR(TD(s), bgcolor='#C00000')
    g_errors.append(s)

table_model = TABLE(Class="content")
table = table_model

model = None
opt = None
method = None

res = None
res_h = []
res_t = None

if history_obj <> None:
   _a = history_obj[0]
   model = history_obj[1]
   _m = model.ID()
   opt = history_obj[2]
   _f = opt.familyName()
   _o = type(opt).__name__
   method = history_obj[3]
   _meth = type(method).__name__
   res_labels = history_obj[4]
   res = history_obj[5]
   res_t = history_obj[6]
   h_iterate_label = history_obj[7]
   res_h = history_obj[8]
   
if 'asset_type' in REQUEST:
   new_asset_type = assets.all()[int(_asset_type)].__name__
   if _a <> new_asset_type:
      _a = new_asset_type
      _model = 0
      _family = 0
      _option = 0
      _pricing_method = 0
      run_computation = True
      _iterate_model = _iterate_option = _iterate_method = '0' 

def printAsset(table, asset_id):
   if not history_mode:
      mc = enum_submit('asset_type', assets.all(), asset_id)
   else:
      mc = asset_id
   table <= (TR(TD((B('Asset Type:')),align='right') + TD(mc)+TD(),bgcolor=mod_colors[0]))


#printAsset(table, _a)

clridx = 0

model_list = eval('assets.' + _a + '.models()')

saved_m = _m 

if 'model' in REQUEST:
   new_model = model_list[int(_model)].ID()
   if _m <> new_model:
      _m = new_model
      _family = 0
      _option = 0
      _pricing_method = 0
      run_computation = True
      _iterate_model = _iterate_option = _iterate_method = '0' 

def clrinc():
   globals()['clridx'] = globals()['clridx'] + 1
   
def row(colors, c_1, c_2, c_3=""):
   return (TR(TD(c_1,align='right') + TD(c_2)+TD(c_3),bgcolor=clr(colors,clridx)))

def rowinc(colors, c_1, c_2, c_3=""):
   clrinc()
   return row(colors, c_1, c_2, c_3)

def printModelType(table, model_type):
   if history_mode:
      mc = model_type
   else:
      mc = enum_submit('model', model_list, model_type)
   table <= rowinc(mod_colors, B('Model:'), mc)
   
"""
   asset_id = h[0]
   printAsset(table_model_h, asset_id)
   model_list = eval('assets.' + asset_id + '.models()')

   model = h[1]
   Include(r'/premia/mod/'+ model.ID() + '/model.py')
   eval('model_' + model.ID() + '(table_model_h, model)')

   opt = h[2]
   Include(r'/premia/opt/' + opt.familyName() + r'/' + type(opt).__name__ + '.py')
   opt = eval('opt_' + opt.familyName() + '_' + type(opt).__name__ + '(table_opt_h, opt)')

   method = h[3]
   res_labels = h[4]
   res = h[5]
   res_t = h[6]
   h_iterate_label = h[7]
   res_h = h[8]
   
   #print h_idx, res_labels

   Include(r'/premia/mod/' + model.ID() + '/' + model.ID() + '_' + opt.familyName() + '/' + type(method).__name__ + '.py')
   method = eval('method_'+model.ID()+'_'+opt.familyName()+'_'+type(method).__name__+'(table_meth_h, method)')

"""

def processModel(m):
   def inner(v):
      v.setModel(m.underlyingType(), m.name())
      for x in m.fields(): x.process(v)
      return v   
   return inner

def processOption(m):
   def inner(v):
      v.setOption(m.underlyingType(), m.familyName(), m.name())
      for x in m.fields(): x.process(v)
      return v
   return inner

def processMethod(m):
   def inner(v):
      v.setMethod(m.underlyingType(), m.name())
      for x in m.fields(): x.process(v)
      v.printResultSeries(m.resultFields())
      return v      
   return inner

def myImport(m):
   exec 'import ' + m
   return eval(m)

def getModelModule(m): 
   return myImport('kspremia.mod.' + m + '.model')

def getOptionModule(f,o):
   return myImport('kspremia.opt.'+f+'.'+o)    

def getMethodModule(m,f,meth): 
   return myImport('kspremia.mod.'+m+'.'+m+'_'+f+'.'+meth)

def lookupModel(m):
   return processModel(getModelModule(m))
   
def lookupOption(f,o):
   return processOption(getOptionModule(f,o))

def lookupMethod(m,f,meth):
   return processMethod(getMethodModule(m,f,meth))

class StateBase(object):

   def __init__(self, parent):
      self.parent = parent

   @cached_property
   def request(self):
      return saved_REQUEST

   @cached_property
   def iterationLabel(self):
      return self.request['il'] if 'il' in self.request else None

   @cached_property
   def fixedIterationIdx(state):
      if state.oldIterationIdx == state.iterationIdx and state.iterationLabel <> None and state.iterationIdx <> 0:
         if state.iterationIdx >= len(state.iterables) or state.iterationLabel <> state.iterables.getCorrectedName(state.iterationIdx):
            return state.iterables.lookupByCorrectedName(state.iterationLabel)
      return state.iterationIdx

   @cached_property
   def iterateVlabel(self):
      return 'iterate_' + self.entityLabel

   @cached_property
   def iterateValueVlabel(self):
      return self.iterateVlabel + '_' + self.iterables.getCorrectedName(self.fixedIterationIdx)

   @cached_property
   def oldIterationValue(self):
      if self.iterateValueVlabel in self.request:
         return float(self.request[self.iterateValueVlabel])
      else:
         return self.iterables.getGetter(self.fixedIterationIdx)()

   @cached_property
   def iterationStepNumber(self):
      return int(self.request['iteration_steps']) if 'iteration_steps' in self.request else 10

   @cached_property
   def iteration(self):
      if self.fixedIterationIdx == 0:
         return None
      else:
         return IterationState(self.obj, self.iterables, self.fixedIterationIdx, self.oldIterationValue, self.iterationStepNumber)

   @cached_property
   def addIterationTable(state):
      clrinc()
      table = state.paramTable
         
      table <= (TR(TD(('Iterate'),align='right') + \
                   TD(enum_submit_mod(state.iterateVlabel, state.iterables.labels, state.iterables.labels[state.fixedIterationIdx]))+\
                   TD(),bgcolor=clr(state.colors,clridx)))
      
      if state.fixedIterationIdx <> 0:
      
         clrinc()
         old_value = state.oldIterationValue
         table <= (TR(TD(('Iterate To'),align='right') + TD(INPUT(name=state.iterateValueVlabel,value=old_value))+TD(),bgcolor=clr(state.colors,clridx)))
         
         clrinc()      
         steps_no = state.iterationStepNumber 
         table <= (TR(TD(('#Iterations'),align='right') + TD(INPUT(name='iteration_steps',value=steps_no))+TD(),bgcolor=clr(state.colors,clridx)))

      return table


class AssetState(StateBase):

   @cached_property
   def assets(self):
      return assets.all()

   @cached_property
   def old_id(self):
      if 'a' in self.request:
         return self.request['a']
      else:
         return 'equity_Black_Scholes_type'  # to be generalized

   @cached_property
   def id(self):
      if 'asset_type' in self.request:
         return self.assets[int(self.request['asset_type'])].__name__
      else:
         return self.old_id

   @cached_property
   def idChanged(self):
      return self.old_id <> self.id

   @cached_property
   def table(self):
      mc = enum_submit('asset_type', self.assets, self.id)
      table = TABLE(Class="content")
      table <= (TR(TD((B('Asset Type:')),align='right') + TD(mc)+TD(),bgcolor=mod_colors[0]))
      return table


class ModelState(StateBase):

   @property
   def entityLabel(self):
      return 'model'

   @property
   def colors(self):
      return mod_colors

   @cached_property
   def models(self):
      return eval('assets.' + self.parent.asset.id + '.models()')

   @cached_property
   def old_id(self):
      if 'm' in self.request:
         return self.request['m']
      else:
         return 'BS1D'  # to be generalized

   @cached_property
   def id(self):
      if self.parent.asset.idChanged:
         return self.models[0].ID()
      else:
         if 'model' in self.request:
            return self.models[int(self.request['model'])].ID()
         else:
            return self.old_id

   @cached_property
   def idChanged(self):
      return self.old_id <> self.id

   @cached_property
   def visit(self):
      return lookupModel(self.id)

   @cached_property
   def obj(self):
      return self.visit(ModelLoader(self)).model

   @cached_property
   def assetTable(self):
      return self.parent.asset.table

   @cached_property
   def paramTable(self):
      return self.visit(ModelRenderer(self)).table

   @cached_property
   def table(self):
      return self.addIterationTable

   @cached_property
   def iterables(self):
      return self.visit(ModelIterablesExtractor(self)).ctx

   @cached_property
   def oldIterationIdx(self):
      return int(self.request['im'] if 'im' in self.request else '0')

   @cached_property
   def srcIterationIdx(self):
      return int(self.request['iterate_model'] if 'iterate_model' in self.request else '0') 

   @cached_property
   def iterationIdx(self):
      if self.idChanged or \
         self.parent.option.iterationIdxChanged or \
         self.parent.method.iterationIdxChanged:
            return 0
      else:
         return self.srcIterationIdx  

   @cached_property
   def iterationIdxChanged(self):
      return self.oldIterationIdx <> self.srcIterationIdx

class FamilyState(StateBase):

   @cached_property
   def families(self):
      return self.parent.model.obj.families()

   @cached_property
   def old_id(self):
      if 'f' in self.request:
         return self.request['f']
      else:
         return 'STD'  # to be generalized

   @cached_property
   def id(self):
      if self.parent.model.idChanged:
         return self.families[0]
      elif 'family' in self.request:
         return self.families[int(self.request['family'])]
      else:
         return self.old_id

   @cached_property
   def idChanged(self):
      return self.old_id <> self.id

   @cached_property
   def table(self):
      mc = enum_submit_mod('family', self.families, self.id)
      table = TABLE(Class="content")
      table <= (TR(TD(B('Family:'),align='right') + TD(mc)+TD(),bgcolor=opt_colors[0]))
      return table

class OptionState(StateBase):

   @property
   def entityLabel(self):
      return 'option'

   @property
   def colors(self):
      return opt_colors

   @cached_property
   def options(self):
      return pricing_options(self.parent.model.id,self.parent.family.id)

   @cached_property
   def old_id(self):
      if 'o' in self.request:
         return self.request['o']
      else:
         return 'CallEuro'  # to be generalized

   @cached_property
   def id(self):
      if self.parent.family.idChanged:
         return self.options[0].__name__
      else:
         if 'option' in self.request:
            return self.options[int(self.request['option'])].__name__
         else:
            return self.old_id

   @cached_property
   def idChanged(self):
      return self.old_id <> self.id

   @cached_property
   def visit(self):
      return lookupOption(self.parent.family.id, self.id)

   @cached_property
   def obj(self):
      return self.visit(OptionLoader(self)).option

   @cached_property
   def familyTable(self):
      return self.parent.family.table

   @cached_property
   def paramTable(self):
      return self.visit(OptionRenderer(self)).table

   @cached_property
   def table(self):
      return self.addIterationTable

   @cached_property
   def iterables(self):
      return self.visit(OptionIterablesExtractor(self)).ctx

   @cached_property
   def oldIterationIdx(self):
      return int(self.request['io'] if 'io' in self.request else '0')

   @cached_property
   def srcIterationIdx(self):
      return int(self.request['iterate_option'] if 'iterate_option' in self.request else '0') 

   @cached_property
   def iterationIdx(self):
      if self.idChanged or \
         self.parent.model.iterationIdxChanged or \
         self.parent.method.iterationIdxChanged:
            return 0
      else:
         return self.srcIterationIdx  

   @cached_property
   def iterationIdxChanged(self):
      return self.oldIterationIdx <> self.srcIterationIdx

class ResultMember(object):

   def __init__(self, correctedName, friendlyName):
      self.friendlyName = friendlyName
      self.correctedName = correctedName

   @cached_property
   def request(self):
      return REQUEST

   @cached_property
   def oldLabel(self):
      if 'showGraphLabel_'+self.correctedName in self.request:
         return self.request['showGraphLabel_'+self.correctedName]
      else: 
         return self.friendlyName

   def render(self, table): 
         clrinc()
         old_checked = result_kinds[self.correctedName][0]

         table <= TR(
                     TD() + 
                     TD( # input box to enter label for this graph serie
                        INPUT(name='showGraphLabel_'+self.correctedName,
                              value=self.oldLabel,
                              disabled = False)) + 
                     TD( # check box should be this serie shown on the graph
                        checkbox('showGraph_'+self.correctedName,
                                 checked = old_checked, 
                                 disabled = False)),
                     bgcolor=clr(table.colors,clridx))

class MethodState(StateBase):

   @property
   def entityLabel(self):
      return 'method'

   @property
   def colors(self):
      return met_colors

   @cached_property
   def methods(self):
      m = self.parent.model.id
      f = self.parent.family.id
      opt = self.parent.option.obj
      return [x for x in eval('pricings.' + m + '.' + m + '_' + f + '.all()') if type(opt) in x.options()]

   @cached_property
   def old_id(self):
      if 'meth' in self.request:
         return self.request['meth']
      else:
         return 'CF_Call'  # to be generalized

   @cached_property
   def id(self):
      if self.parent.option.idChanged or self.parent.model.idChanged:
         return self.methods[0].__name__
      else:
         if 'pricing_method' in self.request:
            return self.methods[int(self.request['pricing_method'])].__name__
         else:
            return self.old_id

   @cached_property
   def idChanged(self):
      return self.old_id <> self.id

   @cached_property
   def ksModule(self):
      return getMethodModule(self.parent.model.id, self.parent.family.id, self.id)

   @cached_property
   def visit(self):
      return processMethod(self.ksModule)

   @cached_property
   def obj(self):
      return self.visit(MethodLoader(self)).method

   @cached_property
   def origTable(self):
      return TABLE(Class="content")

   def printResultTable(self, table):
      table.colors = self.colors
      if state.iteration <> None: 
         clrinc()
         table <= TR(TD('Show results in a graph', colspan='3'),bgcolor=clr(self.colors,clridx))
         for (vlabel, friendly) in self.ksModule.resultFields():
            ResultMember(vlabel, friendly).render(table)
         ResultMember('Time', 'Computation Time').render(table)


   @cached_property
   def paramTable(self):
      table = self.visit(MethodRenderer(self)).table
      self.printResultTable(table)
      return table

   @cached_property
   def table(self):
      return self.addIterationTable

   @cached_property
   def iterables(self):
      return self.visit(MethodIterablesExtractor(self)).ctx

   @cached_property
   def oldIterationIdx(self):
      return int(self.request['ip'] if 'ip' in self.request else '0')

   @cached_property
   def srcIterationIdx(self):
      return int(self.request['iterate_method'] if 'iterate_method' in self.request else '0') 

   @cached_property
   def iterationIdx(self):
      if self.idChanged or \
         self.parent.option.iterationIdxChanged or \
         self.parent.model.iterationIdxChanged:
            return 0
      else:
         return self.srcIterationIdx  

   @cached_property
   def iterationIdxChanged(self):
      return self.oldIterationIdx <> self.srcIterationIdx



"""
Class representing a single run.
"""
class State(object):

   def __init__(self):
      self.asset = AssetState(self)
      self.model = ModelState(self)
      self.family = FamilyState(self)
      self.option = OptionState(self)
      self.method = MethodState(self)

   @cached_property
   def iteration(self):
      return self.model.iteration or self.option.iteration or self.method.iteration

   @cached_property
   def iterationLabel(self):
      return self.iteration.label if self.iteration <> None else '_'

   @cached_property
   def request(self):
      return saved_REQUEST

   computation_timeout = 30

   @cached_property
   def runComputation(self):
      return g_errors == [] and 'Compute' in self.request

   @cached_property
   def result(self):
      if not self.runComputation or self.iteration <> None:
         return None
      def F(opt, mod, q):
         begin = time()
         res = self.method.obj(opt, mod)
         end = time()
         res.append(("Time", end - begin))
         q.put(res)
      try:
         queue = Queue()
         process = Process(target = F, args = (self.option.obj,self.model.obj, queue))
         process.start()
         try:
            return queue.get(timeout=computation_timeout)
         except Empty, exc:
            process.terminate()
            raise Exception("Method has worked more than " + str(computation_timeout) + "s. Please try another parameter combination")
         process.join(timeout=computation_timeout)
      except Exception, exc:
         add_error(exc) 

   @cached_property
   def tableResult(self):

      if not self.runComputation or self.iteration == None:
         return None

      iteration = self.iteration

      def G(opt, mod, q):
         initial = iteration.getter()            
         for i in range(iteration.stepsNo):
             begin = time()
             if iteration.stepsNo > 1:
                 x = initial + 1. * i / (iteration.stepsNo - 1) * (iteration.iterateTo - initial)
             else:
                 x = initial
                 
             if type(initial) == type(1):
                 x = int(round(x))
             if type(initial) == type(1L):
                 x = long(round(x))
             
             iteration.setter(x)
                  
             res = (self.method.obj(opt, mod))
             end = time()
             res.insert(0, (iteration.name, x))
             res.append(("Time", end - begin))
             q.put(res)
      
      try: 
         queue = Queue()
         res_t = []
         process = Process(target = G, args = (self.option.obj,self.model.obj, queue))
         try:            
            process.start()

            begin = time()
            iterations = iteration.stepsNo
            for i in range(iterations):
              q = queue.get(timeout=begin + computation_timeout - time())
              if res_t == []:
                  for k,v in q:
                      res_t.append((k,[v]))
              else:
                  idx = 0
                  for k,v in q:
                      assert res_t[idx][0] == k
                      res_t[idx][1].append(v)
                      idx = idx + 1
                             
         except Empty, exc:
            process.terminate()
            raise Exception("Method has worked more than " + str(computation_timeout) + "s. Please try another parameter combination")
                     
         process.join(timeout=computation_timeout)
         return res_t
         
      except Exception, exc:
         add_error(exc)
   
state = State()
model = state.model.obj
table = table_model = state.model.table
model_iterables = state.model.iterables

visitModel = lookupModel(_m)
#model = visitModel(ModelLoader(model)).model
#visitModel(ModelRenderer(table_model, model))
#modelIterablesExtractor = ModelIterablesExtractor(model)
#visitModel(modelIterablesExtractor)
#processIteration(state.model)
#state.model.addIterationTable()
#model = modelIterablesExtractor.model

print "m=",_m, model

table_option = TABLE(Class="content")
table = table_option

if 'family' in REQUEST:
   new_family = model.families()[int(_family)]
   if new_family <> _f:
      _f = new_family
      _option = 0
      _pricing_method = 0
      run_computation = False
      _iterate_option = _iterate_method = '0' 

def printFamilyType(table, family_type):
   if not history_mode:
      mc = enum_submit_mod('family', model.families(), family_type)
   else:
      mc = family_type
   table <= rowinc(opt_colors, B('Family:'), mc)

if 'option' in REQUEST:
   new_opt = pricing_options(_m,_f)[int(_option)].__name__
   if new_opt <> _o:
      _o = new_opt
      _pricing_method = 0
      run_computation = False
      _iterate_option = _iterate_method = '0' 

def printOptionType(table, option_type):
   if not history_mode:
      mc = enum_submit('option', pricing_options(_m,_f), option_type)
   else:
      mc = option_type
   table <= rowinc(opt_colors, B('Option:'), mc)

clridx = 1

table = table_option = state.family.table
opt = state.option.obj
table = table_option = state.option.table
option_iterables = state.option.iterables

#visitOption = lookupOption(_f, _o)
#opt = visitOption(OptionLoader(opt)).option
#visitOption(OptionRenderer(table_option, opt))
#optionIterablesExtractor = OptionIterablesExtractor(opt)
#visitOption(optionIterablesExtractor)
#processIteration(state.option)
#state.option.addIterationTable()
#opt = optionIterablesExtractor.option

print "_f=",_f, "_o=",_o, opt

table_method = TABLE(Class="content")
table = table_method

if 'pricing_method' not in REQUEST:
   _pricing_method = '0'
   
methods = [x for x in eval('pricings.' + _m + '.' + _m + '_' + _f + '.all()') if type(opt) in x.options()]
new_meth = methods[int(_pricing_method)].__name__
if _meth <> new_meth:
   _meth = new_meth
   run_computation = False
   _iterate_method = '0' 

clridx = 1

def printMethodType(table, method_type):
   if not history_mode:
      mc = enum_submit('pricing_method', methods, method_type)
   else:
      mc = method_type
   table <= rowinc(met_colors, B('Pricing method:'), mc)

method = state.method.obj
table = table_method = state.method.table
method_iterables = state.method.iterables

#visitMethod = lookupMethod(_m,_f,_meth)
#method = visitMethod(MethodLoader(method)).method
#visitMethod(MethodRenderer(table_method, method))
#methodIterablesExtractor = MethodIterablesExtractor(method)
#visitMethod(methodIterablesExtractor)
#processIteration(state.method)
#state.method.addIterationTable()
#method = methodIterablesExtractor.method

print "_meth=",_meth, method

def n_elem(lst):
    acc = 0
    for i in lst:
        acc += REQUEST.has_key(i)
    return acc


table_result_i = TABLE(Class="content")

computation_timeout = 30

if g_errors <> []:
    run_computation = False

if 'Compute' not in REQUEST:
   run_computation = False

 
res = state.result
res_t = state.tableResult 
"""
if run_computation and len(REQUEST) > n_elem(['m','f','o','meth',"Model_Size"]):
    try:
        def F(opt,model,q):
            begin = time()
            res = (method(opt,model))
            end = time()
            res.append(("Time", end - begin))
            q.put(res)

        def G(opt,model,q, iteration):
            initial = iteration.getter()            
            for i in range(iteration.stepsNo):
                begin = time()
                if iteration.stepsNo > 1:
                    x = initial + 1. * i / (iteration.stepsNo - 1) * (iteration.iterateTo - initial)
                else:
                    x = initial
                    
                if type(initial) == type(1):
                    x = int(round(x))
                if type(initial) == type(1L):
                    x = long(round(x))
                
                iteration.setter(x)
                     
                res = (method(opt,model))
                end = time()
                res.insert(0, (iteration.name, x))
                res.append(("Time", end - begin))
                q.put(res)
            
        res = []
        queue = Queue()
        if state.iteration == None:
            process = Process(target = F, args = (opt,model,queue))
        else:
            res_t = []
            process = Process(target = G, args = (opt,model,queue, state.iteration))
        process.start()
        try:
            if state.iteration == None:
                res.extend(queue.get(timeout=computation_timeout))
            else:
                begin = time()
                iterations = state.iteration.stepsNo
                for i in range(iterations):
                    q = queue.get(timeout=begin + computation_timeout - time())
                    res.extend(q)
                    if res_t == []:
                        for k,v in q:
                            res_t.append((k,[v]))
                    else:
                        idx = 0
                        for k,v in q:
                            assert res_t[idx][0] == k
                            res_t[idx][1].append(v)
                            idx = idx + 1
                    
        except Empty, exc:
            if res == []: res = None
            if res_t == []: res_t = None
            process.terminate()
            raise Exception("Method has worked more than " + str(computation_timeout) + "s. Please try another parameter combination")
            
        process.join(timeout=computation_timeout)
    except Exception, exc:
        #print "exception caught:"
        #print traceback.format_exc()
        add_error(exc)
"""
#Include(r'premia/run_computation.py')
#Include(r'premia/print_table_result.py')
def script(s):
   """
    print "<script type=\"text/javascript\">"
    print s
    print "</script>"
   """
   return SCRIPT(s, type=r"text/javascript")

def todata(header, v):
   s = "["
   for i in range(len(v)):
      s += "[" + str(header[i]) + "," + str(v[i]) + "],"
   s += "]"
   return s

#print REQUEST

datas = {}

def corrected(s):
   r = ""
   for c in s:
      if c.isalnum():
         r += c
      else:
         r += '_'
   return r

result_labels = []
def printVectorResult(table_result_i, res_t):
    table_result_i <= script("var datas = []")
    idx = 1
    res_h = []
    for k,v in res_t:
        idx = idx + 1
        is_header = k == res_t[0][0]
        is_selected = ('showGraph_' + k in REQUEST)
  
        if not is_header and is_selected:
           kind = result_kinds[k][1]
           if kind not in datas: datas[kind] = []

        if type(v[0]) == list:

            table_result_i <= TR(TD(k, align='right',rowspan=len(v[0])) + Sum([TD(L[0]) for L in v]),bgcolor=clr(res_colors,idx))

            if not is_header:
               result_labels.extend(map(lambda i: (REQUEST['showGraphLabel_' + k]+"["+str(i)+"]", ('showGraph_' + k in REQUEST)), range(len(v[0]))))          
            
            if not is_header and is_selected:               
                #table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], map(lambda L: L[0], v))+", label : \'"+REQUEST['showGraphLabel_' + k]+"[0]\' })")
                datas[kind].append(("\'"+REQUEST['showGraphLabel_' + k]+"[0]\'", todata(res_t[0][1], map(lambda L: L[0], v))))    
            for i in range(1, len(v[0])):
                table_result_i <= TR(Sum([TD(L[i])  for L in v]),bgcolor=clr(res_colors,idx))
                if not is_header and is_selected:               
                   #table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], map(lambda L: L[i], v))+", label : \'"+REQUEST['showGraphLabel_' + k]+"["+str(i)+"]\' })")          
                   datas[kind].append(("\'"+REQUEST['showGraphLabel_' + k]+"["+str(i)+"]\'", todata(res_t[0][1], map(lambda L: L[i], v))))    
        else:
            table_result_i <= TR(TD(k,align='right') + Sum([TD(L) for L in v]),bgcolor=clr(res_colors,idx))
            if not is_header:
               result_labels.append((REQUEST['showGraphLabel_' + k], ('showGraph_' + k in REQUEST)))
               
            if not is_header and is_selected:               
               #table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], v)+", label : \'"+REQUEST['showGraphLabel_' + k]+"\' })")          
               datas[kind].append(("\'"+REQUEST['showGraphLabel_' + k]+"\'", todata(res_t[0][1], v)))    

    for hh_idx in range(len(session.history)):
      h_idx = len(session.history) - hh_idx - 1
      h = session.history[h_idx]
      h_results = h[6]
      h_iterate_label = h[7]
      if h_results <> None and h_iterate_label == state.iteration.label:
         res_hh = []
         res_lh = []
         for i in range(len(h_results)):
            hk,hv = h_results[i]
            
            if i <> 0:
               kind = result_kinds[hk][1]
               if kind not in datas: datas[kind] = []
  
            if type(hv[0]) == list:
               for j in range(len(hv[0])):
                  vlabel = str(h_idx) + "_" + hk + str(j)
                  if 'showGraph_'+vlabel in REQUEST:

                     if res_hh == []:
                           res_hh = [h_results[0]]

                     res_hh.append((hk+"_"+str(h_idx), map(lambda x: x[j], hv)))
                     res_lh.append(REQUEST['showGraphLabel_'+ vlabel])

                     #table_result_i <= script("datas.push({ data : "+todata(h_results[0][1], map(lambda L: L[j], hv))+", label : \'"+REQUEST['showGraphLabel_' + vlabel]+"\' })")          
                     datas[kind].append(("\'"+REQUEST['showGraphLabel_' + vlabel]+"\'", todata(h_results[0][1], map(lambda L: L[j], hv))))    
            else:
               vlabel = str(h_idx) + "_" + hk
            
               if 'showGraph_'+vlabel in REQUEST:
                 
                  if res_hh == []:
                        res_hh = [h_results[0]]
                    
                  res_hh.append((hk+"_"+str(h_idx), hv))
                  res_lh.append(REQUEST['showGraphLabel_'+ vlabel])
                     
                  ddd = todata(h_results[0][1], hv)
                  #table_result_i <= script("datas.push({ data : "+ddd+", label : \'"+REQUEST['showGraphLabel_' + vlabel]+"\' })")          
                  datas[kind].append(("\'"+REQUEST['showGraphLabel_' + vlabel]+"\'", ddd))    
         
         if res_hh <> []: res_h.append((res_hh, res_lh))
    #print res_h
    return res_h

Include(r'premia/print_scalar_result.py')        

if res_t == None and res <> None:
   printScalarResult(table_method, res)


if res_t <> None:
   res_h = printVectorResult(table_result_i, res_t)
   
#print 'iterate_model = ', _iterate_model
#im = str(_iterate_model)
im = str(state.model.fixedIterationIdx)
#print 'iterate_option = ', _iterate_option
#io = str(_iterate_option)
io = str(state.option.fixedIterationIdx)
#print 'iterate_method = ', _iterate_method
#ip = str(_iterate_method)
ip = str(state.method.fixedIterationIdx)


form = FORM(action='/index?a='+ _a +'&m='+ _m +'&f='+ _f +'&o='+ _o +'&meth=' + _meth+'&im=' + im+'&io=' + io+'&ip=' + ip+'&il='+state.iterationLabel,method="post")

if model_size_mode:
    table_method <= table_model_size_mode
    table_method <= BR()+INPUT(Type="submit",value="Continue")
else:
    table_method <= TR(TD() + TD(INPUT(Type="submit",name="Compute",value="Compute")))
    
if len(g_errors) > 0:
    form <= TR(TD(g_err_table))

g_table <= TR(TD(table_model,valign='top') + TD(table_option,valign='top') + TD(table_method,valign='top'))

if 'history' not in dir(session):
   session.history = []


if 'ClearHistory' in REQUEST:
   session.history = []
   
form <= g_table


if res_t <> None:
   form <= table_result_i 

graph_t = """
  <head>
  </head>
  <body>
    <style type="text/css">
      body {
        margin: 0px;
        padding: 0px;
      }
      #qqq {
        width : 600px;
        height: 384px;
        margin: 8px auto;
      }
    </style>
  <table>
   <tr>
      <td>
         <div id="qqq">
      </td>
   </tr>
  </table>
    <!--[if lt IE 9]>
    <script type="text/javascript" src="flashcanvas.js"></script>
    <![endif]-->
    <script type="text/javascript" src="premia/flotr2.min.js"></script>
    <script type="text/javascript">
(function basic_legend(container) {

  var
    graph;


  function labelFn (label) {
    return label;
  }

  // Draw graph
  graph = Flotr.draw(container, datas, {
    legend : {
      position : 'se',            // Position the legend 'south-east'.
      labelFormatter : labelFn,   // Format the labels.
      backgroundColor : '#D2E8FF' // A light blue background color.
    },
    HtmlText : false
  });
})(document.getElementById('qqq'));      
    </script>
  </body>
"""

if res_t <> None:
    values = datas.values()
    for i in range(len(values)):
        form <= script("data"+str(i)+" = [];")
        for label, sc in values[i]:
            form <= script("data"+str(i)+".push({ data : "+sc+", label : "+label+" });")          
        if values[i] <> []:
           form <= TEXT(graph_t.replace('qqq','containers' + str(i)).replace("datas", "data"+str(i)))

history_mode = True

#print form

if 'result_labels' not in dir():
   result_labels = [] 

to_save = None

if res_t <> None or res <> None:   
   to_save = (_a, model, opt, method, result_labels, res, res_t, state.iterationLabel, res_h)

#print REQUEST

def printVectorHistoryResult(table_result_i, res_t, res_labels): #ddd
    idx = 1
    rli = -1
    
    #print res_labels
    
    for k,v in res_t:
        idx = idx + 1
        is_header = k == res_t[0][0]

        if type(v[0]) == list:

            table_result_i <= TR(TD(k, align='right',rowspan=len(v[0])) + Sum([TD(L[0]) for L in v]),bgcolor=clr(res_colors,idx))
            
            if res_labels[rli][1]:               
            
                table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], map(lambda L: L[0], v))+", label : \'"+res_labels[rli][0]+"\' })")
            
            rli = rli + 1
                
            for i in range(1, len(v[0])):
                table_result_i <= TR(Sum([TD(L[i])  for L in v]),bgcolor=clr(res_colors,idx))
    
                if res_labels[rli][1]:               
                   table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], map(lambda L: L[i], v))+", label : \'"+ res_labels[rli][0]  +"\' })")         
                rli = rli + 1 
        else:
            table_result_i <= TR(TD(k,align='right') + Sum([TD(L) for L in v]),bgcolor=clr(res_colors,idx))
               
            if not is_header and res_labels[rli][1]:               
               table_result_i <= script("datas.push({ data : "+todata(res_t[0][1], v)+", label : \'"+res_labels[rli][0]+"\' })")        
            rli = rli + 1  

if to_save <> None:
   session.history.append(to_save)

if session.history <> []:
   form <= INPUT(Type="submit",name="ClearHistory",value="Clear history")

for hh_idx in range(len(session.history)):

   h_idx = len(session.history) - hh_idx - 1
   h = session.history[h_idx]

   g_table = TABLE(Class="content")

   table_model_h = TABLE(Class="content")
   table_opt_h = TABLE(Class="content")
   table_meth_h = TABLE(Class="content")

   asset_id = h[0]
   printAsset(table_model_h, asset_id)
   model_list = eval('assets.' + asset_id + '.models()')

   model = h[1]
   visitModel = lookupModel(model.ID())
   visitModel(ModelHistoricalRenderer(table_model_h, model))

   opt = h[2]
   visitOption = lookupOption(opt.familyName(), type(opt).__name__)
   visitOption(OptionHistoricalRenderer(table_opt_h, opt))

   method = h[3]
   res_labels = h[4]
   res = h[5]
   res_t = h[6]
   h_iterate_label = h[7]
   res_h = h[8]
   
   #print h_idx, res_labels
   
   visitMethod = lookupMethod(model.ID(), opt.familyName(), type(method).__name__)
   visitMethod(MethodHistoricalRenderer(table_meth_h, method))
      
   if res_t == None and res <> None:
      printScalarResult(table_meth_h, res)

   g_table <= TR(TD(table_model_h,valign='top')+TD(table_opt_h,valign='top')+TD(table_meth_h,valign='top'))

   form <= g_table

   form <= script("var datas = []")

   if res_t <> None:
      table_result_h = TABLE(Class="content")
      printVectorHistoryResult(table_result_h, res_t, res_labels)
      form <= table_result_h
   
   for (res_hh, res_lh) in res_h:
      res_hf = [(l,True) for l in res_lh]
      table_result_h = TABLE(Class="content")
      printVectorHistoryResult(table_result_h, res_hh, res_hf)
      form <= table_result_h
   
   if res_t <> None or res_h <> []:
       qqq = 'container' + str(h_idx)
       #Include(r'premia/graph.pih') 
       form <= TEXT(graph_t.replace('qqq',qqq))

print form


